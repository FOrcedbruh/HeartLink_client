import { createRequire } from 'module';
var require = createRequire(import.meta['url']);

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// ../../node_modules/.pnpm/@modern-js+module-tools@2.59.0_typescript@5.5.2/node_modules/@modern-js/module-tools/shims/esm.js
import path from "path";
import { fileURLToPath } from "url";
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => path.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();

// src/index.ts
import { join } from "path";
import deepmerge from "deepmerge";
import { reduceConfigsWithContext } from "reduce-configs";

// src/helpers.ts
import path2 from "path";
import { pathToFileURL } from "url";
var GLOBAL_PATCHED_SYMBOL = Symbol("GLOBAL_PATCHED_SYMBOL");
function patchGlobalLocation() {
  if (!global.location) {
    const href = pathToFileURL(process.cwd()).href + path2.sep;
    const location = Object.freeze({ [GLOBAL_PATCHED_SYMBOL]: true, href });
    global.location = location;
  }
}
function unpatchGlobalLocation() {
  if (global.location?.[GLOBAL_PATCHED_SYMBOL]) {
    delete global.location;
  }
}
function patchCompilerGlobalLocation(compiler) {
  compiler.hooks.run.tap("PatchGlobalLocation", patchGlobalLocation);
  compiler.hooks.watchRun.tap("PatchGlobalLocation", patchGlobalLocation);
  compiler.hooks.watchClose.tap("PatchGlobalLocation", unpatchGlobalLocation);
  compiler.hooks.done.tap("PatchGlobalLocation", unpatchGlobalLocation);
}
var getResolveUrlJoinFn = async () => {
  const {
    createJoinFunction,
    asGenerator,
    createJoinImplementation,
    defaultJoinGenerator
  } = await import("../compiled/resolve-url-loader/index.js");
  const rsbuildGenerator = asGenerator((item, ...rest) => {
    if (!item.uri.startsWith(".")) {
      return [null];
    }
    return defaultJoinGenerator(item, ...rest);
  });
  return createJoinFunction(
    "rsbuild-resolve-join-fn",
    createJoinImplementation(rsbuildGenerator)
  );
};

// src/index.ts
var PLUGIN_SASS_NAME = "rsbuild:sass";
var getSassLoaderOptions = (userOptions, isUseCssSourceMap) => {
  const excludes = [];
  const addExcludes = (items) => {
    excludes.push(...Array.isArray(items) ? items : [items]);
  };
  const mergeFn = (defaults, userOptions2) => {
    const getSassOptions = () => {
      if (defaults.sassOptions && userOptions2.sassOptions) {
        return deepmerge(
          defaults.sassOptions,
          userOptions2.sassOptions
        );
      }
      return userOptions2.sassOptions || defaults.sassOptions;
    };
    return {
      ...defaults,
      ...userOptions2,
      sassOptions: getSassOptions()
    };
  };
  const mergedOptions = reduceConfigsWithContext({
    initial: {
      sourceMap: isUseCssSourceMap,
      api: "modern-compiler",
      implementation: __require.resolve("sass-embedded")
    },
    config: userOptions,
    ctx: { addExcludes },
    mergeFn
  });
  return {
    options: mergedOptions,
    excludes
  };
};
var pluginSass = (pluginOptions = {}) => ({
  name: PLUGIN_SASS_NAME,
  setup(api) {
    api.onAfterCreateCompiler(({ compiler }) => {
      patchCompilerGlobalLocation(compiler);
    });
    api.modifyBundlerChain(async (chain, { CHAIN_ID }) => {
      const { excludes, options } = getSassLoaderOptions(
        pluginOptions.sassLoaderOptions,
        // source-maps required for loaders preceding resolve-url-loader
        // otherwise the resolve-url-loader will throw an error
        true
      );
      const rule = chain.module.rule(CHAIN_ID.RULE.SASS).test(/\.s(?:a|c)ss$/).merge({ sideEffects: true }).resolve.preferRelative(true).end();
      for (const item of excludes) {
        rule.exclude.add(item);
      }
      if (pluginOptions.exclude) {
        rule.exclude.add(pluginOptions.exclude);
      }
      const cssRule = chain.module.rules.get(CHAIN_ID.RULE.CSS);
      for (const id of Object.keys(cssRule.uses.entries())) {
        const loader = cssRule.uses.get(id);
        const options2 = loader.get("options") ?? {};
        const clonedOptions = deepmerge({}, options2);
        if (id === CHAIN_ID.USE.CSS) {
          clonedOptions.importLoaders += 2;
        }
        rule.use(id).loader(loader.get("loader")).options(clonedOptions);
      }
      rule.use(CHAIN_ID.USE.RESOLVE_URL).loader(join(__dirname, "../compiled/resolve-url-loader/index.js")).options({
        join: await getResolveUrlJoinFn(),
        // 'resolve-url-loader' relies on 'adjust-sourcemap-loader',
        // it has performance regression issues in some scenarios,
        // so we need to disable the sourceMap option.
        sourceMap: false
      }).end().use(CHAIN_ID.USE.SASS).loader(join(__dirname, "../compiled/sass-loader/index.js")).options(options);
    });
  }
});
export {
  PLUGIN_SASS_NAME,
  pluginSass
};
