"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge5(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge5;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge5;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge5(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge5.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge5(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge5;
    module2.exports = deepmerge_1;
  }
});

// src/constants.ts
var import_node_path, ROOT_DIST_DIR, HTML_DIST_DIR, JS_DIST_DIR, CSS_DIST_DIR, SVG_DIST_DIR, FONT_DIST_DIR, WASM_DIST_DIR, IMAGE_DIST_DIR, MEDIA_DIST_DIR, LOADER_PATH, STATIC_PATH, COMPILED_PATH, TS_CONFIG_FILE, HMR_SOCKET_PATH, RSBUILD_OUTPUTS_PATH, DEFAULT_PORT, DEFAULT_DATA_URL_SIZE, DEFAULT_MOUNT_ID, DEFAULT_DEV_HOST, DEFAULT_ASSET_PREFIX, DEFAULT_WEB_BROWSERSLIST, DEFAULT_BROWSERSLIST, HTML_REGEX, JS_REGEX, SCRIPT_REGEX, CSS_REGEX, NODE_MODULES_REGEX, PLUGIN_SWC_NAME, PLUGIN_CSS_NAME, FONT_EXTENSIONS, IMAGE_EXTENSIONS, VIDEO_EXTENSIONS, AUDIO_EXTENSIONS;
var init_constants = __esm({
  "src/constants.ts"() {
    "use strict";
    import_node_path = require("path");
    ROOT_DIST_DIR = "dist";
    HTML_DIST_DIR = "./";
    JS_DIST_DIR = "static/js";
    CSS_DIST_DIR = "static/css";
    SVG_DIST_DIR = "static/svg";
    FONT_DIST_DIR = "static/font";
    WASM_DIST_DIR = "static/wasm";
    IMAGE_DIST_DIR = "static/image";
    MEDIA_DIST_DIR = "static/media";
    LOADER_PATH = (0, import_node_path.join)(__dirname);
    STATIC_PATH = (0, import_node_path.join)(__dirname, "../static");
    COMPILED_PATH = (0, import_node_path.join)(__dirname, "../compiled");
    TS_CONFIG_FILE = "tsconfig.json";
    HMR_SOCKET_PATH = "/rsbuild-hmr";
    RSBUILD_OUTPUTS_PATH = ".rsbuild";
    DEFAULT_PORT = 3e3;
    DEFAULT_DATA_URL_SIZE = 4096;
    DEFAULT_MOUNT_ID = "root";
    DEFAULT_DEV_HOST = "0.0.0.0";
    DEFAULT_ASSET_PREFIX = "/";
    DEFAULT_WEB_BROWSERSLIST = [
      "chrome >= 87",
      "edge >= 88",
      "firefox >= 78",
      "safari >= 14"
    ];
    DEFAULT_BROWSERSLIST = {
      web: DEFAULT_WEB_BROWSERSLIST,
      "web-worker": DEFAULT_WEB_BROWSERSLIST,
      node: ["node >= 16"]
    };
    HTML_REGEX = /\.html$/;
    JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/;
    SCRIPT_REGEX = /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/;
    CSS_REGEX = /\.css$/;
    NODE_MODULES_REGEX = /[\\/]node_modules[\\/]/;
    PLUGIN_SWC_NAME = "rsbuild:swc";
    PLUGIN_CSS_NAME = "rsbuild:css";
    FONT_EXTENSIONS = [
      "woff",
      "woff2",
      "eot",
      "ttf",
      "otf",
      "ttc"
    ];
    IMAGE_EXTENSIONS = [
      "png",
      "jpg",
      "jpeg",
      "pjpeg",
      "pjp",
      "gif",
      "bmp",
      "webp",
      "ico",
      "apng",
      "avif",
      "tif",
      "tiff",
      "jfif"
    ];
    VIDEO_EXTENSIONS = ["mp4", "webm", "ogg", "mov"];
    AUDIO_EXTENSIONS = [
      "mp3",
      "wav",
      "flac",
      "aac",
      "m4a",
      "opus"
    ];
  }
});

// src/logger.ts
function getTime() {
  const now = /* @__PURE__ */ new Date();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${hours}:${minutes}:${seconds}`;
}
var import_picocolors, import_rslog, isDebug;
var init_logger = __esm({
  "src/logger.ts"() {
    "use strict";
    import_picocolors = __toESM(require("../compiled/picocolors/index.js"));
    import_rslog = require("../compiled/rslog/index.js");
    isDebug = () => {
      if (!process.env.DEBUG) {
        return false;
      }
      const values = process.env.DEBUG.toLocaleLowerCase().split(",");
      return ["rsbuild", "builder", "*"].some((key) => values.includes(key));
    };
    if (isDebug()) {
      import_rslog.logger.level = "verbose";
    }
    import_rslog.logger.override({
      debug: (message, ...args) => {
        if (import_rslog.logger.level !== "verbose") {
          return;
        }
        const time = import_picocolors.default.gray(`${getTime()}`);
        console.log(`  ${import_picocolors.default.magenta("rsbuild")} ${time} ${message}`, ...args);
      }
    });
  }
});

// src/helpers/fs.ts
function isEmptyDir(path20) {
  const files = import_node_fs.default.readdirSync(path20);
  return files.length === 0 || files.length === 1 && files[0] === ".git";
}
async function pathExists(path20) {
  return import_node_fs.default.promises.access(path20).then(() => true).catch(() => false);
}
async function isFileExists(file) {
  return import_node_fs.default.promises.access(file, import_node_fs.default.constants.F_OK).then(() => true).catch(() => false);
}
async function fileExistsByCompilation({ inputFileSystem }, filePath) {
  return new Promise((resolve2) => {
    if (!inputFileSystem) {
      resolve2(false);
      return;
    }
    inputFileSystem.stat(filePath, (err, stats) => {
      if (err) {
        resolve2(false);
      } else {
        resolve2(Boolean(stats?.isFile()));
      }
    });
  });
}
async function emptyDir(dir) {
  if (!await pathExists(dir)) {
    return;
  }
  try {
    for (const file of await import_node_fs.default.promises.readdir(dir)) {
      await import_node_fs.default.promises.rm(import_node_path2.default.resolve(dir, file), {
        recursive: true,
        force: true
      });
    }
  } catch (err) {
    import_rslog.logger.debug(`Failed to empty dir: ${dir}`);
    import_rslog.logger.debug(err);
  }
}
var import_node_fs, import_node_path2, isFileSync, findExists;
var init_fs = __esm({
  "src/helpers/fs.ts"() {
    "use strict";
    import_node_fs = __toESM(require("fs"));
    import_node_path2 = __toESM(require("path"));
    init_logger();
    isFileSync = (filePath) => {
      try {
        return import_node_fs.default.statSync(filePath, { throwIfNoEntry: false })?.isFile();
      } catch (_) {
        return false;
      }
    };
    findExists = (files) => {
      for (const file of files) {
        if (isFileSync(file)) {
          return file;
        }
      }
      return false;
    };
  }
});

// src/helpers/path.ts
function getAbsolutePath(base, filepath) {
  return (0, import_node_path3.isAbsolute)(filepath) ? filepath : (0, import_node_path3.join)(base, filepath);
}
function getCommonParentPath(paths) {
  const uniquePaths = [...new Set(paths)];
  if (uniquePaths.length === 1) {
    return uniquePaths[0];
  }
  const [first, ...rest] = uniquePaths.map((p) => p.split(import_node_path3.sep));
  const common = [];
  for (let i = 0; i < first.length; i++) {
    const segment = first[i];
    if (rest.every((p) => p[i] === segment)) {
      common.push(segment);
    } else {
      break;
    }
  }
  return common.join(import_node_path3.sep);
}
var import_node_path3, getCompiledPath, ensureAbsolutePath, pathnameParse;
var init_path = __esm({
  "src/helpers/path.ts"() {
    "use strict";
    import_node_path3 = require("path");
    init_constants();
    getCompiledPath = (packageName) => (0, import_node_path3.join)(COMPILED_PATH, packageName, "index.js");
    ensureAbsolutePath = (base, filePath) => (0, import_node_path3.isAbsolute)(filePath) ? filePath : (0, import_node_path3.resolve)(base, filePath);
    pathnameParse = (publicPath) => {
      try {
        return publicPath ? new URL(publicPath).pathname : publicPath;
      } catch (err) {
        return publicPath;
      }
    };
  }
});

// src/client/format.ts
function resolveFileName(stats) {
  if (stats.moduleIdentifier) {
    const regex = /(?:\!|^)([^!]+)$/;
    const matched = stats.moduleIdentifier.match(regex);
    if (matched) {
      const fileName = matched.pop();
      if (fileName) {
        return `File: ${fileName}:1:1
`;
      }
    }
  }
  const file = stats.file || stats.moduleName;
  return file ? `File: ${file}
` : "";
}
function hintUnknownFiles(message) {
  const hint = "You may need an appropriate loader to handle this file type.";
  if (message.indexOf(hint) === -1) {
    return message;
  }
  if (/File: .+\.s(c|a)ss/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Sass, use "@rsbuild/plugin-sass".`
    );
  }
  if (/File: .+\.less/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Less, use "@rsbuild/plugin-less".`
    );
  }
  if (/File: .+\.styl(us)?/.test(message)) {
    return message.replace(
      hint,
      `To enable support for Stylus, use "@rsbuild/plugin-stylus".`
    );
  }
  return message;
}
function formatMessage(stats, verbose) {
  let lines = [];
  let message;
  if (typeof stats === "object") {
    const fileName = resolveFileName(stats);
    const mainMessage = stats.message;
    const details = verbose && stats.details ? `
Details: ${stats.details}
` : "";
    const stack = verbose && stats.stack ? `
${stats.stack}` : "";
    message = `${fileName}${mainMessage}${details}${stack}`;
  } else {
    message = stats;
  }
  message = hintUnknownFiles(message);
  lines = message.split("\n");
  lines = lines.filter(
    (line, index, arr) => index === 0 || line.trim() !== "" || line.trim() !== arr[index - 1].trim()
  );
  message = lines.join("\n");
  const innerError = "-- inner error --";
  if (!verbose && message.includes(innerError)) {
    message = message.split(innerError)[0];
  }
  return message.trim();
}
function formatStatsMessages(stats, verbose) {
  const formattedErrors = stats.errors?.map((error) => formatMessage(error, verbose)) || [];
  const formattedWarnings = stats.warnings?.map((warning) => formatMessage(warning, verbose)) || [];
  return {
    errors: formattedErrors,
    warnings: formattedWarnings
  };
}
var init_format = __esm({
  "src/client/format.ts"() {
    "use strict";
  }
});

// src/helpers/stats.ts
function formatErrorMessage(errors) {
  const messages = errors.map((error) => hintNodePolyfill(error));
  const text = `${messages.join("\n\n")}
`;
  const title = import_picocolors2.default.bold(import_picocolors2.default.red("Compile error: "));
  if (!errors.length) {
    return `${title}
${import_picocolors2.default.yellow(`For more details, please setting 'stats.errors: true' `)}`;
  }
  const tip = import_picocolors2.default.yellow(
    "Failed to compile, check the errors for troubleshooting."
  );
  return `${title}
${tip}
${text}`;
}
function getStatsOptions(compiler) {
  if (isMultiCompiler(compiler)) {
    return {
      children: compiler.compilers.map(
        (compiler2) => compiler2.options ? compiler2.options.stats : void 0
      )
    };
  }
  return compiler.options ? compiler.options.stats : void 0;
}
function formatStats(stats, options = {}) {
  const statsData = stats.toJson(
    typeof options === "object" ? {
      preset: "errors-warnings",
      children: true,
      ...options
    } : options
  );
  const { errors, warnings } = formatStatsMessages(
    {
      errors: getAllStatsErrors(statsData),
      warnings: getAllStatsWarnings(statsData)
    },
    // display verbose messages in debug mode
    import_rslog.logger.level === "verbose"
  );
  if (stats.hasErrors()) {
    return {
      message: formatErrorMessage(errors),
      level: "error"
    };
  }
  if (warnings.length) {
    const title = import_picocolors2.default.bold(import_picocolors2.default.yellow("Compile Warning: \n"));
    return {
      message: `${title}${warnings.join("\n\n")}
`,
      level: "warning"
    };
  }
  return {};
}
var import_picocolors2, hintNodePolyfill, getAllStatsErrors, getAllStatsWarnings;
var init_stats = __esm({
  "src/helpers/stats.ts"() {
    "use strict";
    import_picocolors2 = __toESM(require("../compiled/picocolors/index.js"));
    init_format();
    init_logger();
    init_helpers();
    hintNodePolyfill = (message) => {
      if (!message.includes(`Can't resolve`)) {
        return message;
      }
      const matchArray = message.match(/Can't resolve '(\w+)'/);
      if (!matchArray) {
        return message;
      }
      const moduleName = matchArray[1];
      const nodeModules = [
        "assert",
        "buffer",
        "child_process",
        "cluster",
        "console",
        "constants",
        "crypto",
        "dgram",
        "dns",
        "domain",
        "events",
        "fs",
        "http",
        "https",
        "module",
        "net",
        "os",
        "path",
        "punycode",
        "process",
        "querystring",
        "readline",
        "repl",
        "stream",
        "_stream_duplex",
        "_stream_passthrough",
        "_stream_readable",
        "_stream_transform",
        "_stream_writable",
        "string_decoder",
        "sys",
        "timers",
        "tls",
        "tty",
        "url",
        "util",
        "vm",
        "zlib"
      ];
      if (moduleName && nodeModules.includes(moduleName)) {
        const tips = [
          `Tip: "${moduleName}" is a built-in Node.js module and cannot be imported in client-side code.`,
          `Check if you need to import Node.js module. If needed, you can use "@rsbuild/plugin-node-polyfill".`
        ];
        return `${message}

${import_picocolors2.default.yellow(tips.join("\n"))}`;
      }
      return message;
    };
    getAllStatsErrors = (statsData) => {
      if (statsData.errorsCount && statsData.errors?.length === 0) {
        return statsData.children?.reduce(
          (errors, curr) => errors.concat(curr.errors || []),
          []
        );
      }
      return statsData.errors;
    };
    getAllStatsWarnings = (statsData) => {
      if (statsData.warningsCount && statsData.warnings?.length === 0) {
        return statsData.children?.reduce(
          (warnings, curr) => warnings.concat(curr.warnings || []),
          []
        );
      }
      return statsData.warnings;
    };
  }
});

// src/helpers/index.ts
function getFilename(config, type, isProd, isServer) {
  const { filename, filenameHash } = config.output;
  const getHash = () => {
    if (typeof filenameHash === "string") {
      return filenameHash ? `.[${filenameHash}]` : "";
    }
    return filenameHash ? ".[contenthash:8]" : "";
  };
  const hash = getHash();
  switch (type) {
    case "js":
      return filename.js ?? `[name]${isProd && !isServer ? hash : ""}.js`;
    case "css":
      return filename.css ?? `[name]${isProd ? hash : ""}.css`;
    case "svg":
      return filename.svg ?? `[name]${hash}.svg`;
    case "font":
      return filename.font ?? `[name]${hash}[ext]`;
    case "image":
      return filename.image ?? `[name]${hash}[ext]`;
    case "media":
      return filename.media ?? `[name]${hash}[ext]`;
    default:
      throw new Error(`unknown key ${type} in "output.filename"`);
  }
}
function partition(array, predicate) {
  const truthy = [];
  const falsy = [];
  for (const value of array) {
    if (predicate(value)) {
      truthy.push(value);
    } else {
      falsy.push(value);
    }
  }
  return [truthy, falsy];
}
function debounce(func, wait) {
  let timeoutId = null;
  return (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      func(...args);
    }, wait);
  };
}
function isWebTarget(target) {
  const targets = castArray(target);
  return targets.includes("web") || target.includes("web-worker");
}
function pick(obj, keys) {
  return keys.reduce(
    (ret, key) => {
      if (obj[key] !== void 0) {
        ret[key] = obj[key];
      }
      return ret;
    },
    {}
  );
}
var import_node_path4, import_deepmerge, import_picocolors3, rspackMinVersion, getNodeEnv, setNodeEnv, isFunction, isObject, isPlainObject, castArray, cloneDeep, compareSemver, isSatisfyRspackVersion, removeLeadingSlash, removeTailingSlash, addTrailingSlash, formatPublicPath, getPublicPathFromChain, getPublicPathFromCompiler, urlJoin, canParse, ensureAssetPrefix, applyToCompiler, upperFirst, isURL, createVirtualModule, isMultiCompiler, camelCase, prettyTime;
var init_helpers = __esm({
  "src/helpers/index.ts"() {
    "use strict";
    import_node_path4 = require("path");
    import_deepmerge = __toESM(require_cjs());
    import_picocolors3 = __toESM(require("../compiled/picocolors/index.js"));
    init_constants();
    init_fs();
    init_path();
    init_stats();
    rspackMinVersion = "1.0.0";
    getNodeEnv = () => process.env.NODE_ENV;
    setNodeEnv = (env) => {
      process.env.NODE_ENV = env;
    };
    isFunction = (func) => typeof func === "function";
    isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
    isPlainObject = (o) => {
      if (isObject(o) === false)
        return false;
      const ctor = o.constructor;
      if (ctor === void 0)
        return true;
      const prot = ctor.prototype;
      if (isObject(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
    castArray = (arr) => {
      if (arr === void 0) {
        return [];
      }
      return Array.isArray(arr) ? arr : [arr];
    };
    cloneDeep = (value) => {
      if (value === null || value === void 0) {
        return value;
      }
      return (0, import_deepmerge.default)({}, value, {
        isMergeableObject: isPlainObject
      });
    };
    compareSemver = (version1, version2) => {
      const parts1 = version1.split(".").map(Number);
      const parts2 = version2.split(".").map(Number);
      const len = Math.max(parts1.length, parts2.length);
      for (let i = 0; i < len; i++) {
        const item1 = parts1[i] ?? 0;
        const item2 = parts2[i] ?? 0;
        if (item1 > item2) {
          return 1;
        }
        if (item1 < item2) {
          return -1;
        }
      }
      return 0;
    };
    isSatisfyRspackVersion = async (originalVersion) => {
      let version2 = originalVersion;
      if (version2.includes("-canary")) {
        version2 = version2.split("-canary")[0];
      }
      if (version2 && /^[\d\.]+$/.test(version2)) {
        return compareSemver(version2, rspackMinVersion) >= 0;
      }
      return true;
    };
    removeLeadingSlash = (s) => s.replace(/^\/+/, "");
    removeTailingSlash = (s) => s.replace(/\/+$/, "");
    addTrailingSlash = (s) => s.endsWith("/") ? s : `${s}/`;
    formatPublicPath = (publicPath, withSlash = true) => {
      if (publicPath === "auto") {
        return publicPath;
      }
      return withSlash ? addTrailingSlash(publicPath) : removeTailingSlash(publicPath);
    };
    getPublicPathFromChain = (chain, withSlash = true) => {
      const publicPath = chain.output.get("publicPath");
      if (typeof publicPath === "string") {
        return formatPublicPath(publicPath, withSlash);
      }
      return formatPublicPath(DEFAULT_ASSET_PREFIX, withSlash);
    };
    getPublicPathFromCompiler = (compiler) => {
      const { publicPath } = compiler.options.output;
      if (typeof publicPath === "string") {
        if (publicPath === "auto") {
          return "";
        }
        return publicPath.endsWith("/") ? publicPath : `${publicPath}/`;
      }
      return DEFAULT_ASSET_PREFIX;
    };
    urlJoin = (base, path20) => {
      const fullUrl = new URL(base);
      fullUrl.pathname = import_node_path4.posix.join(fullUrl.pathname, path20);
      return fullUrl.toString();
    };
    canParse = (url2) => {
      try {
        new URL(url2);
        return true;
      } catch {
        return false;
      }
    };
    ensureAssetPrefix = (url2, assetPrefix = DEFAULT_ASSET_PREFIX) => {
      if (url2.startsWith("//")) {
        return url2;
      }
      if (canParse(url2)) {
        return url2;
      }
      if (assetPrefix === "auto") {
        return url2;
      }
      if (typeof assetPrefix === "function") {
        return url2;
      }
      if (assetPrefix.startsWith("http")) {
        return urlJoin(assetPrefix, url2);
      }
      if (assetPrefix.startsWith("//")) {
        return urlJoin(`https:${assetPrefix}`, url2).replace("https:", "");
      }
      return import_node_path4.posix.join(assetPrefix, url2);
    };
    applyToCompiler = (compiler, apply) => {
      if (isMultiCompiler(compiler)) {
        compiler.compilers.forEach(apply);
      } else {
        apply(compiler, 0);
      }
    };
    upperFirst = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1) : "";
    isURL = (str) => str.startsWith("http") || str.startsWith("//:");
    createVirtualModule = (content) => `data:text/javascript,${content}`;
    isMultiCompiler = (compiler) => {
      return compiler.constructor.name === "MultiCompiler";
    };
    camelCase = (input) => input.replace(/[-_](\w)/g, (_, c) => c.toUpperCase());
    prettyTime = (seconds) => {
      const format = (time) => import_picocolors3.default.bold(time);
      if (seconds < 10) {
        const digits = seconds >= 0.01 ? 2 : 3;
        return `${format(seconds.toFixed(digits))} s`;
      }
      if (seconds < 60) {
        return `${format(seconds.toFixed(1))} s`;
      }
      const minutes = seconds / 60;
      return `${format(minutes.toFixed(2))} m`;
    };
  }
});

// src/mergeConfig.ts
var OVERRIDE_PATHS, isOverridePath, merge, mergeRsbuildConfig;
var init_mergeConfig = __esm({
  "src/mergeConfig.ts"() {
    "use strict";
    init_helpers();
    OVERRIDE_PATHS = [
      "performance.removeConsole",
      "output.inlineScripts",
      "output.inlineStyles",
      "output.cssModules.auto",
      "output.overrideBrowserslist",
      "server.open",
      "server.printUrls",
      "provider"
    ];
    isOverridePath = (key) => {
      if (key.startsWith("environments.")) {
        const realKey = key.split(".").slice(2).join(".");
        return OVERRIDE_PATHS.includes(realKey);
      }
      return OVERRIDE_PATHS.includes(key);
    };
    merge = (x, y, path20 = "") => {
      if (isOverridePath(path20)) {
        return y ?? x;
      }
      if (x === void 0) {
        return isPlainObject(y) ? cloneDeep(y) : y;
      }
      if (y === void 0) {
        return isPlainObject(x) ? cloneDeep(x) : x;
      }
      if (typeof x === "boolean" || typeof y === "boolean") {
        return y;
      }
      const pair = [x, y];
      if (pair.some(Array.isArray)) {
        return [...castArray(x), ...castArray(y)];
      }
      if (pair.some(isFunction)) {
        return pair;
      }
      if (!isPlainObject(x) || !isPlainObject(y)) {
        return y;
      }
      const merged = {};
      const keys = /* @__PURE__ */ new Set([...Object.keys(x), ...Object.keys(y)]);
      for (const key of keys) {
        const childPath = path20 ? `${path20}.${key}` : key;
        merged[key] = merge(x[key], y[key], childPath);
      }
      return merged;
    };
    mergeRsbuildConfig = (...configs) => {
      if (configs.length === 2) {
        return merge(configs[0], configs[1]);
      }
      if (configs.length < 2) {
        return configs[0];
      }
      return configs.reduce(
        (result, config) => merge(result, config),
        {}
      );
    };
  }
});

// src/server/restart.ts
var import_node_path5, import_picocolors4, cleaners, onBeforeRestartServer, clearConsole, restartDevServer;
var init_restart = __esm({
  "src/server/restart.ts"() {
    "use strict";
    import_node_path5 = __toESM(require("path"));
    import_picocolors4 = __toESM(require("../compiled/picocolors/index.js"));
    init_init();
    init_logger();
    cleaners = [];
    onBeforeRestartServer = (cleaner) => {
      cleaners.push(cleaner);
    };
    clearConsole = () => {
      if (process.stdout.isTTY && !process.env.DEBUG) {
        process.stdout.write("\x1B[H\x1B[2J");
      }
    };
    restartDevServer = async ({
      filePath
    }) => {
      clearConsole();
      const filename = import_node_path5.default.basename(filePath);
      import_rslog.logger.info(`Restart because ${import_picocolors4.default.yellow(filename)} is changed.
`);
      for (const cleaner of cleaners) {
        await cleaner();
        cleaners = [];
      }
      const rsbuild = await init({ isRestart: true });
      if (!rsbuild) {
        return;
      }
      await rsbuild.startDevServer();
    };
  }
});

// src/config.ts
function getDefaultEntry(root) {
  const files = [
    // Most projects are using typescript now.
    // So we put `.ts` as the first one to improve performance.
    "ts",
    "js",
    "tsx",
    "jsx",
    "mjs",
    "cjs"
  ].map((ext) => (0, import_node_path6.join)(root, `src/index.${ext}`));
  const entryFile = findExists(files);
  if (entryFile) {
    return {
      index: entryFile
    };
  }
  return {};
}
function defineConfig(config) {
  return config;
}
async function watchFiles(files, watchOptions) {
  if (!files.length) {
    return;
  }
  const chokidar = await import("../compiled/chokidar/index.js");
  const watcher = chokidar.watch(files, {
    // do not trigger add for initial files
    ignoreInitial: true,
    // If watching fails due to read permissions, the errors will be suppressed silently.
    ignorePermissionErrors: true,
    ...watchOptions
  });
  const callback = debounce(
    async (filePath) => {
      watcher.close();
      await restartDevServer({ filePath });
    },
    // set 300ms debounce to avoid restart frequently
    300
  );
  watcher.on("add", callback);
  watcher.on("change", callback);
  watcher.on("unlink", callback);
}
async function loadConfig({
  cwd = process.cwd(),
  path: path20,
  envMode
} = {}) {
  const configFilePath = resolveConfigPath(cwd, path20);
  if (!configFilePath) {
    return {
      content: {},
      filePath: configFilePath
    };
  }
  const applyMetaInfo = (config) => {
    config._privateMeta = { configFilePath };
    return config;
  };
  let configExport;
  if (/\.(?:js|mjs|cjs)$/.test(configFilePath)) {
    try {
      const exportModule = await import(`${configFilePath}?t=${Date.now()}`);
      configExport = exportModule.default ? exportModule.default : exportModule;
    } catch (err) {
      import_rslog.logger.debug(
        `Failed to load file with dynamic import: ${import_picocolors5.default.dim(configFilePath)}`
      );
    }
  }
  try {
    if (configExport === void 0) {
      const { default: jiti } = await import("../compiled/jiti/index.js");
      const loadConfig2 = jiti(__filename, {
        esmResolve: true,
        // disable require cache to support restart CLI and read the new config
        requireCache: false,
        interopDefault: true
      });
      configExport = loadConfig2(configFilePath);
    }
  } catch (err) {
    import_rslog.logger.error(`Failed to load file with jiti: ${import_picocolors5.default.dim(configFilePath)}`);
    throw err;
  }
  if (typeof configExport === "function") {
    const command = process.argv[2];
    const nodeEnv = getNodeEnv();
    const params = {
      env: nodeEnv,
      command,
      envMode: envMode || nodeEnv
    };
    const result = await configExport(params);
    if (result === void 0) {
      throw new Error("The config function must return a config object.");
    }
    return {
      content: applyMetaInfo(result),
      filePath: configFilePath
    };
  }
  if (!isObject(configExport)) {
    throw new Error(
      `The config must be an object or a function that returns an object, get ${import_picocolors5.default.yellow(
        configExport
      )}`
    );
  }
  return {
    content: applyMetaInfo(configExport),
    filePath: configFilePath
  };
}
async function outputInspectConfigFiles({
  rawBundlerConfigs,
  rawEnvironmentConfigs,
  inspectOptions,
  configType
}) {
  const { outputPath } = inspectOptions;
  const files = [
    ...rawEnvironmentConfigs.map(({ name, content }) => {
      if (rawEnvironmentConfigs.length === 1) {
        const outputFile2 = "rsbuild.config.mjs";
        const outputFilePath2 = (0, import_node_path6.join)(outputPath, outputFile2);
        return {
          path: outputFilePath2,
          label: "Rsbuild Config",
          content
        };
      }
      const outputFile = `rsbuild.config.${name}.mjs`;
      const outputFilePath = (0, import_node_path6.join)(outputPath, outputFile);
      return {
        path: outputFilePath,
        label: `Rsbuild Config (${name})`,
        content
      };
    }),
    ...rawBundlerConfigs.map(({ name, content }) => {
      const outputFile = `${configType}.config.${name}.mjs`;
      let outputFilePath = (0, import_node_path6.join)(outputPath, outputFile);
      if (import_node_fs2.default.existsSync(outputFilePath)) {
        outputFilePath = outputFilePath.replace(/\.mjs$/, `.${Date.now()}.mjs`);
      }
      return {
        path: outputFilePath,
        label: `${upperFirst(configType)} Config (${name})`,
        content
      };
    })
  ];
  await import_node_fs2.default.promises.mkdir(outputPath, { recursive: true });
  await Promise.all(
    files.map(async (item) => {
      return import_node_fs2.default.promises.writeFile(item.path, `export default ${item.content}`);
    })
  );
  const fileInfos = files.map(
    (item) => `  - ${import_picocolors5.default.bold(import_picocolors5.default.yellow(item.label))}: ${import_picocolors5.default.underline(
      item.path
    )}`
  ).join("\n");
  import_rslog.logger.success(
    `Inspect config succeed, open following files to view the content: 

${fileInfos}
`
  );
}
function stringifyConfig(config, verbose) {
  const stringify = import_rspack_chain.default.toString;
  return stringify(config, { verbose });
}
var import_node_fs2, import_node_path6, import_picocolors5, import_rspack_chain, getDefaultDevConfig, getDefaultServerConfig, getDefaultSourceConfig, getDefaultHtmlConfig, getDefaultSecurityConfig, getDefaultToolsConfig, getDefaultPerformanceConfig, getDefaultOutputConfig, createDefaultConfig, withDefaultConfig, normalizeConfig, resolveConfigPath, getRsbuildInspectConfig, normalizePublicDirs;
var init_config = __esm({
  "src/config.ts"() {
    "use strict";
    import_node_fs2 = __toESM(require("fs"));
    import_node_path6 = require("path");
    import_picocolors5 = __toESM(require("../compiled/picocolors/index.js"));
    import_rspack_chain = __toESM(require("../compiled/rspack-chain/index.js"));
    init_constants();
    init_helpers();
    init_logger();
    init_mergeConfig();
    init_restart();
    getDefaultDevConfig = () => ({
      hmr: true,
      liveReload: true,
      assetPrefix: DEFAULT_ASSET_PREFIX,
      writeToDisk: false,
      client: {
        path: HMR_SOCKET_PATH,
        port: "",
        host: "",
        overlay: true,
        reconnect: 100
      }
    });
    getDefaultServerConfig = () => ({
      port: DEFAULT_PORT,
      host: DEFAULT_DEV_HOST,
      open: false,
      htmlFallback: "index",
      compress: true,
      printUrls: true,
      strictPort: false
    });
    getDefaultSourceConfig = () => ({
      alias: {},
      define: {},
      aliasStrategy: "prefer-tsconfig",
      preEntry: [],
      decorators: {
        version: "2022-03"
      }
    });
    getDefaultHtmlConfig = () => ({
      meta: {
        charset: { charset: "UTF-8" },
        viewport: "width=device-width, initial-scale=1.0"
      },
      title: "Rsbuild App",
      inject: "head",
      mountId: DEFAULT_MOUNT_ID,
      crossorigin: false,
      outputStructure: "flat",
      scriptLoading: "defer"
    });
    getDefaultSecurityConfig = () => ({
      nonce: "",
      sri: {
        enable: false
      }
    });
    getDefaultToolsConfig = () => ({
      cssExtract: {
        loaderOptions: {},
        pluginOptions: {
          ignoreOrder: true
        }
      }
    });
    getDefaultPerformanceConfig = () => ({
      profile: false,
      buildCache: true,
      printFileSize: true,
      removeConsole: false,
      removeMomentLocale: false,
      chunkSplit: {
        strategy: "split-by-experience"
      }
    });
    getDefaultOutputConfig = () => ({
      target: "web",
      cleanDistPath: "auto",
      distPath: {
        root: ROOT_DIST_DIR,
        css: CSS_DIST_DIR,
        svg: SVG_DIST_DIR,
        font: FONT_DIST_DIR,
        html: HTML_DIST_DIR,
        wasm: WASM_DIST_DIR,
        image: IMAGE_DIST_DIR,
        media: MEDIA_DIST_DIR
      },
      assetPrefix: DEFAULT_ASSET_PREFIX,
      filename: {},
      charset: "utf8",
      polyfill: "off",
      dataUriLimit: {
        svg: DEFAULT_DATA_URL_SIZE,
        font: DEFAULT_DATA_URL_SIZE,
        image: DEFAULT_DATA_URL_SIZE,
        media: DEFAULT_DATA_URL_SIZE
      },
      legalComments: "linked",
      injectStyles: false,
      minify: true,
      manifest: false,
      sourceMap: {
        js: void 0,
        css: false
      },
      filenameHash: true,
      inlineScripts: false,
      inlineStyles: false,
      cssModules: {
        auto: true,
        namedExport: false,
        exportGlobals: false,
        exportLocalsConvention: "camelCase"
      },
      emitAssets: true
    });
    createDefaultConfig = () => ({
      dev: getDefaultDevConfig(),
      server: getDefaultServerConfig(),
      html: getDefaultHtmlConfig(),
      source: getDefaultSourceConfig(),
      output: getDefaultOutputConfig(),
      tools: getDefaultToolsConfig(),
      security: getDefaultSecurityConfig(),
      performance: getDefaultPerformanceConfig(),
      environments: {}
    });
    withDefaultConfig = async (rootPath, config) => {
      const merged = mergeRsbuildConfig(createDefaultConfig(), config);
      merged.root ||= rootPath;
      merged.source ||= {};
      if (!merged.source.tsconfigPath) {
        const tsconfigPath = (0, import_node_path6.join)(rootPath, TS_CONFIG_FILE);
        if (await isFileExists(tsconfigPath)) {
          merged.source.tsconfigPath = tsconfigPath;
        }
      }
      return merged;
    };
    normalizeConfig = (config) => {
      const getMode = () => {
        if (config.mode) {
          return config.mode;
        }
        const nodeEnv = getNodeEnv();
        return nodeEnv === "production" || nodeEnv === "development" ? nodeEnv : "none";
      };
      return mergeRsbuildConfig(
        {
          ...createDefaultConfig(),
          mode: getMode()
        },
        config
      );
    };
    resolveConfigPath = (root, customConfig) => {
      if (customConfig) {
        const customConfigPath = (0, import_node_path6.isAbsolute)(customConfig) ? customConfig : (0, import_node_path6.join)(root, customConfig);
        if (import_node_fs2.default.existsSync(customConfigPath)) {
          return customConfigPath;
        }
        import_rslog.logger.warn(`Cannot find config file: ${import_picocolors5.default.dim(customConfigPath)}
`);
      }
      const CONFIG_FILES = [
        // `.mjs` and `.ts` are the most used configuration types,
        // so we resolve them first for performance
        "rsbuild.config.mjs",
        "rsbuild.config.ts",
        "rsbuild.config.js",
        "rsbuild.config.cjs",
        "rsbuild.config.mts",
        "rsbuild.config.cts"
      ];
      for (const file of CONFIG_FILES) {
        const configFile = (0, import_node_path6.join)(root, file);
        if (import_node_fs2.default.existsSync(configFile)) {
          return configFile;
        }
      }
      return null;
    };
    getRsbuildInspectConfig = ({
      normalizedConfig,
      inspectOptions,
      pluginManager
    }) => {
      const { environments, ...rsbuildConfig } = normalizedConfig;
      const pluginNames = pluginManager.getPlugins().map((p) => p.name);
      const rsbuildDebugConfig = {
        ...rsbuildConfig,
        pluginNames
      };
      const rawRsbuildConfig = stringifyConfig(
        rsbuildDebugConfig,
        inspectOptions.verbose
      );
      const environmentConfigs = {};
      const rawEnvironmentConfigs = [];
      for (const [name, config] of Object.entries(environments)) {
        const debugConfig = {
          ...config,
          pluginNames: pluginManager.getPlugins({ environment: name }).map((p) => p.name)
        };
        rawEnvironmentConfigs.push({
          name,
          content: stringifyConfig(debugConfig, inspectOptions.verbose)
        });
        environmentConfigs[name] = debugConfig;
      }
      return {
        rsbuildConfig: rsbuildDebugConfig,
        rawRsbuildConfig,
        environmentConfigs,
        rawEnvironmentConfigs
      };
    };
    normalizePublicDirs = (publicDir) => {
      if (publicDir === false) {
        return [];
      }
      const defaultConfig = {
        name: "public",
        copyOnBuild: true,
        watch: false
      };
      if (publicDir === void 0) {
        return [defaultConfig];
      }
      if (Array.isArray(publicDir)) {
        return publicDir.map((options) => ({
          ...defaultConfig,
          ...options
        }));
      }
      return [
        {
          ...defaultConfig,
          ...publicDir
        }
      ];
    };
  }
});

// src/loadEnv.ts
function loadEnv({
  cwd = process.cwd(),
  mode = getNodeEnv(),
  prefixes = ["PUBLIC_"]
} = {}) {
  if (mode === "local") {
    throw new Error(
      `'local' cannot be used as a value for env mode, because ".env.local" represents a temporary local file. Please use another value.`
    );
  }
  const filenames = [
    ".env",
    ".env.local",
    `.env.${mode}`,
    `.env.${mode}.local`
  ];
  const filePaths = filenames.map((filename) => (0, import_node_path7.join)(cwd, filename)).filter(isFileSync);
  const parsed = {};
  for (const envPath of filePaths) {
    Object.assign(parsed, (0, import_dotenv.parse)(import_node_fs3.default.readFileSync(envPath)));
  }
  if (parsed.NODE_ENV) {
    process.env.NODE_ENV = parsed.NODE_ENV;
  }
  (0, import_dotenv_expand.expand)({ parsed });
  const publicVars = {};
  for (const key of Object.keys(process.env)) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      const val = process.env[key];
      publicVars[`import.meta.env.${key}`] = JSON.stringify(val);
      publicVars[`process.env.${key}`] = JSON.stringify(val);
    }
  }
  let cleaned = false;
  const cleanup = () => {
    if (cleaned) {
      return;
    }
    for (const key of Object.keys(parsed)) {
      if (key === "NODE_ENV") {
        continue;
      }
      if (process.env[key] === parsed[key]) {
        delete process.env[key];
      }
    }
    cleaned = true;
  };
  return {
    parsed,
    cleanup,
    filePaths,
    publicVars
  };
}
var import_node_fs3, import_node_path7, import_dotenv, import_dotenv_expand;
var init_loadEnv = __esm({
  "src/loadEnv.ts"() {
    "use strict";
    import_node_fs3 = __toESM(require("fs"));
    import_node_path7 = require("path");
    import_dotenv = require("../compiled/dotenv/index.js");
    import_dotenv_expand = require("../compiled/dotenv-expand/index.js");
    init_helpers();
  }
});

// src/pluginManager.ts
function validatePlugin(plugin) {
  const type = typeof plugin;
  if (type !== "object" || plugin === null) {
    throw new Error(
      `Expect Rsbuild plugin instance to be an object, but got ${type}.`
    );
  }
  if (isFunction(plugin.setup)) {
    return;
  }
  if (isFunction(plugin.apply)) {
    const { name = "SomeWebpackPlugin" } = plugin.constructor || {};
    const messages = [
      `${import_picocolors6.default.yellow(
        name
      )} looks like a Webpack or Rspack plugin, please use ${import_picocolors6.default.yellow(
        "`tools.rspack`"
      )} to register it:`,
      import_picocolors6.default.green(`
  // rsbuild.config.ts
  export default {
    tools: {
      rspack: {
        plugins: [new ${name}()]
      }
    }
  };
`)
    ];
    throw new Error(messages.join("\n"));
  }
  throw new Error(
    `Expect Rsbuild plugin.setup to be a function, but got ${type}.`
  );
}
function createPluginManager() {
  let plugins = [];
  const addPlugins = (newPlugins, options) => {
    const { before, environment = RSBUILD_ALL_ENVIRONMENT_SYMBOL } = options || {};
    for (const newPlugin of newPlugins) {
      if (!newPlugin) {
        continue;
      }
      validatePlugin(newPlugin);
      const existPlugin = plugins.find(
        (item) => item.instance.name === newPlugin.name && item.environment === environment
      );
      if (existPlugin) {
        import_rslog.logger.warn(
          `Rsbuild plugin "${newPlugin.name}" registered multiple times.`
        );
      } else if (before) {
        const index = plugins.findIndex(
          (item) => item.instance.name === before
        );
        if (index === -1) {
          import_rslog.logger.warn(`Plugin "${before}" does not exist.`);
          plugins.push({
            environment,
            instance: newPlugin
          });
        } else {
          plugins.splice(index, 0, {
            environment,
            instance: newPlugin
          });
        }
      } else {
        plugins.push({
          environment,
          instance: newPlugin
        });
      }
    }
  };
  const removePlugins = (pluginNames, options = {}) => {
    plugins = plugins.filter(
      (plugin) => !(pluginNames.includes(plugin.instance.name) && (!options.environment || plugin.environment === options.environment))
    );
  };
  const isPluginExists = (pluginName, options = {
    environment: RSBUILD_ALL_ENVIRONMENT_SYMBOL
  }) => Boolean(
    plugins.find(
      (plugin) => plugin.instance.name === pluginName && isPluginMatchEnvironment(plugin.environment, options.environment)
    )
  );
  const getPlugins = (options = {
    environment: RSBUILD_ALL_ENVIRONMENT_SYMBOL
  }) => {
    return plugins.filter(
      (p) => isPluginMatchEnvironment(p.environment, options.environment)
    ).map((p) => p.instance);
  };
  return {
    getPlugins,
    getAllPluginsWithMeta: () => plugins,
    addPlugins,
    removePlugins,
    isPluginExists
  };
}
async function initPlugins({
  getPluginAPI,
  pluginManager
}) {
  import_rslog.logger.debug("init plugins");
  const plugins = pluginDagSort(pluginManager.getAllPluginsWithMeta());
  const removedPlugins = plugins.reduce(
    (ret, plugin) => {
      if (plugin.instance.remove) {
        ret[plugin.environment] ??= [];
        ret[plugin.environment].push(...plugin.instance.remove);
      }
      return ret;
    },
    {}
  );
  for (const plugin of plugins) {
    const isGlobalPlugin = plugin.environment === "RSBUILD_ALL_ENVIRONMENT_SYMBOL";
    if (removedPlugins[plugin.environment]?.includes(plugin.instance.name) || !isGlobalPlugin && removedPlugins[RSBUILD_ALL_ENVIRONMENT_SYMBOL]?.includes(
      plugin.instance.name
    )) {
      continue;
    }
    const { instance, environment } = plugin;
    await instance.setup(getPluginAPI(environment));
  }
  import_rslog.logger.debug("init plugins done");
}
var import_picocolors6, RSBUILD_ALL_ENVIRONMENT_SYMBOL, isPluginMatchEnvironment, pluginDagSort;
var init_pluginManager = __esm({
  "src/pluginManager.ts"() {
    "use strict";
    import_picocolors6 = __toESM(require("../compiled/picocolors/index.js"));
    init_helpers();
    init_logger();
    RSBUILD_ALL_ENVIRONMENT_SYMBOL = "RSBUILD_ALL_ENVIRONMENT_SYMBOL";
    isPluginMatchEnvironment = (pluginEnvironment, currentEnvironment) => pluginEnvironment === currentEnvironment || pluginEnvironment === RSBUILD_ALL_ENVIRONMENT_SYMBOL;
    pluginDagSort = (plugins) => {
      let allLines = [];
      function getPlugin(name) {
        const targets = plugins.filter((item) => item.instance.name === name);
        if (!targets.length) {
          throw new Error(`plugin ${name} not existed`);
        }
        return targets;
      }
      for (const plugin of plugins) {
        if (plugin.instance.pre) {
          for (const pre of plugin.instance.pre) {
            if (pre && plugins.some((item) => item.instance.name === pre)) {
              allLines.push([pre, plugin.instance.name]);
            }
          }
        }
        if (plugin.instance.post) {
          for (const post of plugin.instance.post) {
            if (post && plugins.some((item) => item.instance.name === post)) {
              allLines.push([plugin.instance.name, post]);
            }
          }
        }
      }
      let zeroEndPoints = plugins.filter(
        (item) => !allLines.find((l) => l[1] === item.instance.name)
      );
      const sortedPoint = [];
      while (zeroEndPoints.length) {
        const zep = zeroEndPoints.shift();
        sortedPoint.push(...getPlugin(zep.instance.name));
        allLines = allLines.filter(
          (l) => l[0] !== getPlugin(zep.instance.name)[0].instance.name
        );
        const restPoints = plugins.filter(
          (item) => !sortedPoint.find((sp) => sp.instance.name === item.instance.name)
        );
        zeroEndPoints = restPoints.filter(
          (item) => !allLines.find((l) => l[1] === item.instance.name)
        );
      }
      if (allLines.length) {
        const restInRingPoints = {};
        for (const l of allLines) {
          restInRingPoints[l[0]] = true;
          restInRingPoints[l[1]] = true;
        }
        throw new Error(
          `plugins dependencies has loop: ${Object.keys(restInRingPoints).join(
            ","
          )}`
        );
      }
      return sortedPoint;
    };
  }
});

// src/hooks.ts
function createEnvironmentAsyncHook() {
  const preGroup = [];
  const postGroup = [];
  const defaultGroup = [];
  const tapEnvironment = ({
    environment,
    handler: cb
  }) => {
    if (isFunction(cb)) {
      defaultGroup.push({
        environment,
        handler: cb
      });
    } else if (cb.order === "pre") {
      preGroup.push({
        environment,
        handler: cb.handler
      });
    } else if (cb.order === "post") {
      postGroup.push({
        environment,
        handler: cb.handler
      });
    } else {
      defaultGroup.push({
        environment,
        handler: cb.handler
      });
    }
  };
  const callInEnvironment = async ({
    environment,
    args: params
  }) => {
    const callbacks = [...preGroup, ...defaultGroup, ...postGroup];
    for (const callback of callbacks) {
      if (callback.environment && environment && !isPluginMatchEnvironment(callback.environment, environment)) {
        continue;
      }
      const result = await callback.handler(...params);
      if (result !== void 0) {
        params[0] = result;
      }
    }
    return params;
  };
  return {
    tapEnvironment,
    tap: (handler) => tapEnvironment({ handler }),
    callInEnvironment
  };
}
function createAsyncHook() {
  const preGroup = [];
  const postGroup = [];
  const defaultGroup = [];
  const tap = (cb) => {
    if (isFunction(cb)) {
      defaultGroup.push(cb);
    } else if (cb.order === "pre") {
      preGroup.push(cb.handler);
    } else if (cb.order === "post") {
      postGroup.push(cb.handler);
    } else {
      defaultGroup.push(cb.handler);
    }
  };
  const call = async (...params) => {
    const callbacks = [...preGroup, ...defaultGroup, ...postGroup];
    for (const callback of callbacks) {
      const result = await callback(...params);
      if (result !== void 0) {
        params[0] = result;
      }
    }
    return params;
  };
  return {
    tap,
    call
  };
}
function initHooks() {
  return {
    onExit: createAsyncHook(),
    onAfterBuild: createAsyncHook(),
    onBeforeBuild: createAsyncHook(),
    onDevCompileDone: createAsyncHook(),
    onCloseDevServer: createAsyncHook(),
    onAfterStartDevServer: createAsyncHook(),
    onBeforeStartDevServer: createAsyncHook(),
    onAfterStartProdServer: createAsyncHook(),
    onBeforeStartProdServer: createAsyncHook(),
    onAfterCreateCompiler: createAsyncHook(),
    onBeforeCreateCompiler: createAsyncHook(),
    modifyHTMLTags: createEnvironmentAsyncHook(),
    modifyRspackConfig: createEnvironmentAsyncHook(),
    modifyBundlerChain: createEnvironmentAsyncHook(),
    modifyWebpackChain: createEnvironmentAsyncHook(),
    modifyWebpackConfig: createEnvironmentAsyncHook(),
    modifyRsbuildConfig: createAsyncHook(),
    modifyEnvironmentConfig: createEnvironmentAsyncHook(),
    onBeforeEnvironmentCompile: createEnvironmentAsyncHook(),
    onAfterEnvironmentCompile: createEnvironmentAsyncHook()
  };
}
var onBeforeCompile, onCompileDone, registerBuildHook, registerDevHook;
var init_hooks = __esm({
  "src/hooks.ts"() {
    "use strict";
    init_helpers();
    init_pluginManager();
    onBeforeCompile = ({
      compiler,
      beforeCompile,
      beforeEnvironmentCompiler,
      isWatch
    }) => {
      const name = "rsbuild:beforeCompile";
      if (isMultiCompiler(compiler)) {
        const { compilers } = compiler;
        let doneCompilers = 0;
        let waitBeforeCompileDone;
        for (let index = 0; index < compilers.length; index++) {
          const compiler2 = compilers[index];
          let compilerDone = false;
          (isWatch ? compiler2.hooks.watchRun : compiler2.hooks.run).tapPromise(
            name,
            async () => {
              if (!compilerDone) {
                compilerDone = true;
                doneCompilers++;
              }
              if (!waitBeforeCompileDone) {
                waitBeforeCompileDone = beforeCompile?.();
              }
              await waitBeforeCompileDone;
              await beforeEnvironmentCompiler(index);
            }
          );
          compiler2.hooks.invalid.tap(name, () => {
            if (compilerDone) {
              compilerDone = false;
              doneCompilers--;
            }
            if (doneCompilers <= 0) {
              waitBeforeCompileDone = void 0;
            }
          });
        }
      } else {
        (isWatch ? compiler.hooks.watchRun : compiler.hooks.run).tapPromise(
          name,
          async () => {
            await beforeCompile?.();
            await beforeEnvironmentCompiler(0);
          }
        );
      }
    };
    onCompileDone = ({
      compiler,
      onDone,
      onEnvironmentDone,
      MultiStatsCtor
    }) => {
      if (isMultiCompiler(compiler)) {
        const { compilers } = compiler;
        const compilerStats = [];
        let doneCompilers = 0;
        for (let index = 0; index < compilers.length; index++) {
          const compiler2 = compilers[index];
          const compilerIndex = index;
          let compilerDone = false;
          compiler2.hooks.done.tapPromise("rsbuild:done", async (stats) => {
            if (!compilerDone) {
              compilerDone = true;
              doneCompilers++;
            }
            compilerStats[compilerIndex] = stats;
            const lastCompilerDone = doneCompilers === compilers.length;
            await onEnvironmentDone(index, stats);
            if (lastCompilerDone) {
              await onDone(new MultiStatsCtor(compilerStats));
            }
          });
          compiler2.hooks.invalid.tap("rsbuild:done", () => {
            if (compilerDone) {
              compilerDone = false;
              doneCompilers--;
            }
          });
        }
      } else {
        compiler.hooks.done.tapPromise("rsbuild:done", async (stats) => {
          await onEnvironmentDone(0, stats);
          await onDone(stats);
        });
      }
    };
    registerBuildHook = ({
      context,
      isWatch,
      compiler,
      bundlerConfigs,
      MultiStatsCtor
    }) => {
      let isFirstCompile = true;
      const environmentList = Object.values(context.environments).reduce((prev, curr) => {
        prev[curr.index] = curr;
        return prev;
      }, []);
      const beforeCompile = async () => await context.hooks.onBeforeBuild.call({
        bundlerConfigs,
        environments: context.environments,
        isWatch,
        isFirstCompile
      });
      const beforeEnvironmentCompiler = async (buildIndex) => await context.hooks.onBeforeEnvironmentCompile.callInEnvironment({
        environment: environmentList[buildIndex].name,
        args: [
          {
            bundlerConfig: bundlerConfigs?.[buildIndex],
            environment: environmentList[buildIndex],
            isWatch,
            isFirstCompile
          }
        ]
      });
      const onDone = async (stats) => {
        const p = context.hooks.onAfterBuild.call({
          isFirstCompile,
          stats,
          environments: context.environments,
          isWatch
        });
        isFirstCompile = false;
        await p;
      };
      const onEnvironmentDone = async (buildIndex, stats) => {
        await context.hooks.onAfterEnvironmentCompile.callInEnvironment({
          environment: environmentList[buildIndex].name,
          args: [
            {
              isFirstCompile,
              stats,
              environment: environmentList[buildIndex],
              isWatch
            }
          ]
        });
      };
      onBeforeCompile({
        compiler,
        beforeCompile,
        beforeEnvironmentCompiler,
        isWatch
      });
      onCompileDone({
        compiler,
        onDone,
        onEnvironmentDone,
        MultiStatsCtor
      });
    };
    registerDevHook = ({
      context,
      compiler,
      bundlerConfigs,
      MultiStatsCtor
    }) => {
      let isFirstCompile = true;
      const environmentList = Object.values(context.environments).reduce((prev, curr) => {
        prev[curr.index] = curr;
        return prev;
      }, []);
      const beforeEnvironmentCompiler = async (buildIndex) => await context.hooks.onBeforeEnvironmentCompile.callInEnvironment({
        environment: environmentList[buildIndex].name,
        args: [
          {
            bundlerConfig: bundlerConfigs?.[buildIndex],
            environment: environmentList[buildIndex],
            isWatch: true,
            isFirstCompile
          }
        ]
      });
      const onDone = async (stats) => {
        const p = context.hooks.onDevCompileDone.call({
          isFirstCompile,
          stats,
          environments: context.environments
        });
        isFirstCompile = false;
        await p;
      };
      const onEnvironmentDone = async (buildIndex, stats) => {
        await context.hooks.onAfterEnvironmentCompile.callInEnvironment({
          environment: environmentList[buildIndex].name,
          args: [
            {
              isFirstCompile,
              stats,
              environment: environmentList[buildIndex],
              isWatch: true
            }
          ]
        });
      };
      onBeforeCompile({
        compiler,
        beforeEnvironmentCompiler,
        isWatch: true
      });
      onCompileDone({
        compiler,
        onDone,
        onEnvironmentDone,
        MultiStatsCtor
      });
    };
  }
});

// src/initPlugins.ts
function getHTMLPathByEntry(entryName, config) {
  let filename;
  if (config.output.filename.html) {
    filename = config.output.filename.html.replace("[name]", entryName);
  } else if (config.html.outputStructure === "flat") {
    filename = `${entryName}.html`;
  } else {
    filename = `${entryName}/index.html`;
  }
  const prefix = config.output.distPath.html;
  if (prefix.startsWith("/")) {
    import_rslog.logger.warn(
      `Absolute path is not recommended at \`output.distPath.html\`: "${prefix}", please use relative path instead.`
    );
  }
  return removeLeadingSlash(import_node_path8.posix.join(prefix, filename));
}
function initPluginAPI({
  context,
  pluginManager
}) {
  const { hooks } = context;
  const publicContext = createPublicContext(context);
  function getNormalizedConfig(options) {
    if (context.normalizedConfig) {
      if (options?.environment) {
        const config = context.normalizedConfig.environments[options.environment];
        if (!config) {
          throw new Error(
            `Cannot find normalized config by environment: ${options.environment}.`
          );
        }
        return config;
      }
      return context.normalizedConfig;
    }
    throw new Error(
      "Cannot access normalized config until modifyRsbuildConfig is called."
    );
  }
  const getRsbuildConfig = (type = "current") => {
    switch (type) {
      case "original":
        return context.originalConfig;
      case "current":
        return context.config;
      case "normalized":
        return getNormalizedConfig();
    }
    throw new Error("`getRsbuildConfig` get an invalid type param.");
  };
  const exposed = [];
  const expose = (id, api) => {
    exposed.push({ id, api });
  };
  const useExposed = (id) => {
    const matched = exposed.find((item) => item.id === id);
    if (matched) {
      return matched.api;
    }
  };
  let transformId = 0;
  const transformer = {};
  const processAssetsFns = [];
  hooks.modifyBundlerChain.tap((chain, { target, environment }) => {
    const pluginName = "RsbuildCorePlugin";
    class RsbuildCorePlugin {
      apply(compiler) {
        compiler.__rsbuildTransformer = transformer;
        compiler.hooks.thisCompilation.tap(pluginName, (compilation) => {
          compilation.hooks.childCompiler.tap(pluginName, (childCompiler) => {
            childCompiler.__rsbuildTransformer = transformer;
          });
          const { sources } = compiler.webpack;
          for (const {
            descriptor,
            handler,
            environment: pluginEnvironment
          } of processAssetsFns) {
            if (descriptor.targets && !descriptor.targets.includes(target)) {
              return;
            }
            if (descriptor.environments && !descriptor.environments.includes(environment.name) || // the plugin is registered in a specific environment config
            pluginEnvironment && !isPluginMatchEnvironment(pluginEnvironment, environment.name)) {
              return;
            }
            compilation.hooks.processAssets.tapPromise(
              {
                name: pluginName,
                stage: mapProcessAssetsStage(compiler, descriptor.stage)
              },
              async (assets) => handler({
                assets,
                compiler,
                compilation,
                environment,
                sources
              })
            );
          }
        });
      }
    }
    chain.plugin(pluginName).use(RsbuildCorePlugin);
  });
  const getTransformFn = (environment) => (descriptor, handler) => {
    const id = `rsbuild-transform-${transformId++}`;
    transformer[id] = handler;
    hooks.modifyBundlerChain.tapEnvironment({
      environment,
      handler: (chain, { target, environment: environment2 }) => {
        if (descriptor.targets && !descriptor.targets.includes(target)) {
          return;
        }
        if (descriptor.environments && !descriptor.environments.includes(environment2.name)) {
          return;
        }
        const rule = chain.module.rule(id);
        if (descriptor.test) {
          rule.test(descriptor.test);
        }
        if (descriptor.resourceQuery) {
          rule.resourceQuery(descriptor.resourceQuery);
        }
        const loaderName = descriptor.raw ? "transformRawLoader.cjs" : "transformLoader.cjs";
        const loaderPath = (0, import_node_path8.join)(LOADER_PATH, loaderName);
        rule.use(id).loader(loaderPath).options({
          id,
          getEnvironment: () => environment2
        });
      }
    });
  };
  const setProcessAssets = (environment) => (descriptor, handler) => {
    processAssetsFns.push({ environment, descriptor, handler });
  };
  let onExitListened = false;
  const onExit = (cb) => {
    if (!onExitListened) {
      process.on("exit", () => {
        hooks.onExit.call();
      });
      onExitListened = true;
    }
    hooks.onExit.tap(cb);
  };
  return (environment) => ({
    context: publicContext,
    expose,
    transform: getTransformFn(environment),
    useExposed,
    processAssets: setProcessAssets(environment),
    getRsbuildConfig,
    getNormalizedConfig,
    isPluginExists: pluginManager.isPluginExists,
    // Hooks
    onExit,
    onAfterBuild: hooks.onAfterBuild.tap,
    onBeforeBuild: hooks.onBeforeBuild.tap,
    onCloseDevServer: hooks.onCloseDevServer.tap,
    onDevCompileDone: hooks.onDevCompileDone.tap,
    onAfterCreateCompiler: hooks.onAfterCreateCompiler.tap,
    onAfterStartDevServer: hooks.onAfterStartDevServer.tap,
    onBeforeCreateCompiler: hooks.onBeforeCreateCompiler.tap,
    onBeforeStartDevServer: hooks.onBeforeStartDevServer.tap,
    onAfterStartProdServer: hooks.onAfterStartProdServer.tap,
    onBeforeStartProdServer: hooks.onBeforeStartProdServer.tap,
    modifyRsbuildConfig: hooks.modifyRsbuildConfig.tap,
    modifyHTMLTags: (handler) => hooks.modifyHTMLTags.tapEnvironment({
      environment,
      handler
    }),
    modifyBundlerChain: (handler) => hooks.modifyBundlerChain.tapEnvironment({
      environment,
      handler
    }),
    modifyRspackConfig: (handler) => hooks.modifyRspackConfig.tapEnvironment({
      environment,
      handler
    }),
    modifyWebpackChain: (handler) => hooks.modifyWebpackChain.tapEnvironment({
      environment,
      handler
    }),
    modifyWebpackConfig: (handler) => hooks.modifyWebpackConfig.tapEnvironment({
      environment,
      handler
    }),
    modifyEnvironmentConfig: (handler) => hooks.modifyEnvironmentConfig.tapEnvironment({
      environment,
      handler
    }),
    onAfterEnvironmentCompile: (handler) => hooks.onAfterEnvironmentCompile.tapEnvironment({
      environment,
      handler
    }),
    onBeforeEnvironmentCompile: (handler) => hooks.onBeforeEnvironmentCompile.tapEnvironment({
      environment,
      handler
    })
  });
}
var import_node_path8, mapProcessAssetsStage;
var init_initPlugins = __esm({
  "src/initPlugins.ts"() {
    "use strict";
    import_node_path8 = require("path");
    init_constants();
    init_createContext();
    init_helpers();
    init_logger();
    init_pluginManager();
    mapProcessAssetsStage = (compiler, stage) => {
      const { Compilation } = compiler.webpack;
      switch (stage) {
        case "additional":
          return Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL;
        case "pre-process":
          return Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS;
        case "derived":
          return Compilation.PROCESS_ASSETS_STAGE_DERIVED;
        case "additions":
          return Compilation.PROCESS_ASSETS_STAGE_ADDITIONS;
        case "none":
          return Compilation.PROCESS_ASSETS_STAGE_NONE;
        case "optimize":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE;
        case "optimize-count":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT;
        case "optimize-compatibility":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY;
        case "optimize-size":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE;
        case "dev-tooling":
          return Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING;
        case "optimize-inline":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE;
        case "summarize":
          return Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE;
        case "optimize-hash":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH;
        case "optimize-transfer":
          return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER;
        case "analyse":
          return Compilation.PROCESS_ASSETS_STAGE_ANALYSE;
        case "report":
          return Compilation.PROCESS_ASSETS_STAGE_REPORT;
        default:
          throw new Error(`Invalid process assets stage: ${stage}`);
      }
    };
  }
});

// src/createContext.ts
function getAbsoluteDistPath(cwd, config) {
  const dirRoot = config.output?.distPath?.root ?? ROOT_DIST_DIR;
  return getAbsolutePath(cwd, dirRoot);
}
async function getBrowserslist(path20) {
  const env = process.env.NODE_ENV;
  const cacheKey = path20 + env;
  if (browsersListCache.has(cacheKey)) {
    return browsersListCache.get(cacheKey);
  }
  const result = import_browserslist.default.loadConfig({ path: path20, env });
  if (result) {
    browsersListCache.set(cacheKey, result);
    return result;
  }
  return null;
}
async function getBrowserslistByEnvironment(path20, config) {
  const { target, overrideBrowserslist } = config.output;
  if (Array.isArray(overrideBrowserslist)) {
    return overrideBrowserslist;
  }
  if (target === "web" || target === "web-worker") {
    const browserslistrc = await getBrowserslist(path20);
    if (browserslistrc) {
      return browserslistrc;
    }
  }
  return DEFAULT_BROWSERSLIST[target];
}
async function updateEnvironmentContext(context, configs) {
  context.environments ||= {};
  for (const [index, [name, config]] of Object.entries(configs).entries()) {
    const tsconfigPath = config.source.tsconfigPath ? getAbsolutePath(context.rootPath, config.source.tsconfigPath) : void 0;
    const browserslist3 = await getBrowserslistByEnvironment(
      context.rootPath,
      config
    );
    const entry = config.source.entry ?? {};
    const htmlPaths = getEnvironmentHTMLPaths(entry, config);
    const environmentContext = {
      index,
      name,
      distPath: getAbsoluteDistPath(context.rootPath, config),
      entry,
      browserslist: browserslist3,
      htmlPaths,
      tsconfigPath,
      config
    };
    context.environments[name] = new Proxy(environmentContext, {
      get(target, prop) {
        return target[prop];
      },
      set(_, prop) {
        import_rslog.logger.error(
          `EnvironmentContext is readonly, you can not assign to the "environment.${prop}" prop.`
        );
        return true;
      }
    });
  }
}
function updateContextByNormalizedConfig(context) {
  const distPaths = Object.values(context.environments).map(
    (item) => item.distPath
  );
  context.distPath = getCommonParentPath(distPaths);
}
function createPublicContext(context) {
  const exposedKeys = [
    "version",
    "rootPath",
    "distPath",
    "devServer",
    "cachePath",
    "bundlerType"
  ];
  return new Proxy(context, {
    get(target, prop) {
      if (exposedKeys.includes(prop)) {
        return target[prop];
      }
      return void 0;
    },
    set(_, prop) {
      import_rslog.logger.error(
        `Context is readonly, you can not assign to the "context.${prop}" prop.`
      );
      return true;
    }
  });
}
async function createContext(options, userConfig, bundlerType) {
  const { cwd } = options;
  const rootPath = userConfig.root ? getAbsolutePath(cwd, userConfig.root) : cwd;
  const rsbuildConfig = await withDefaultConfig(rootPath, userConfig);
  const cachePath = (0, import_node_path9.join)(rootPath, "node_modules", ".cache");
  return {
    version: "1.0.4",
    rootPath,
    distPath: "",
    cachePath,
    bundlerType,
    environments: {},
    hooks: initHooks(),
    config: { ...rsbuildConfig },
    originalConfig: userConfig,
    specifiedEnvironments: options.environment
  };
}
var import_node_path9, import_browserslist, browsersListCache, getEnvironmentHTMLPaths;
var init_createContext = __esm({
  "src/createContext.ts"() {
    "use strict";
    import_node_path9 = require("path");
    import_browserslist = __toESM(require("../compiled/browserslist/index.js"));
    init_config();
    init_constants();
    init_path();
    init_hooks();
    init_initPlugins();
    init_logger();
    browsersListCache = /* @__PURE__ */ new Map();
    getEnvironmentHTMLPaths = (entry, config) => {
      if (config.output.target !== "web" || config.tools.htmlPlugin === false) {
        return {};
      }
      return Object.keys(entry).reduce((prev, key) => {
        const entryValue = entry[key];
        if (typeof entryValue === "string" || Array.isArray(entryValue) || entryValue.html !== false) {
          prev[key] = getHTMLPathByEntry(key, config);
        }
        return prev;
      }, {});
    };
  }
});

// src/pluginHelper.ts
var import_core, htmlPlugin, setHTMLPlugin, getHTMLPlugin, cssExtractPlugin, setCssExtractPlugin, getCssExtractPlugin;
var init_pluginHelper = __esm({
  "src/pluginHelper.ts"() {
    "use strict";
    import_core = __toESM(require("@rspack/core"));
    setHTMLPlugin = (plugin) => {
      if (plugin) {
        htmlPlugin = plugin;
      }
    };
    getHTMLPlugin = () => {
      if (!htmlPlugin) {
        htmlPlugin = require("../compiled/html-rspack-plugin/index.js");
      }
      return htmlPlugin;
    };
    setCssExtractPlugin = (plugin) => {
      cssExtractPlugin = plugin;
    };
    getCssExtractPlugin = () => {
      if (cssExtractPlugin) {
        return cssExtractPlugin;
      }
      return import_core.default.CssExtractRspackPlugin;
    };
  }
});

// src/provider/inspectConfig.ts
var inspectConfig_exports = {};
__export(inspectConfig_exports, {
  inspectConfig: () => inspectConfig
});
async function inspectConfig({
  context,
  pluginManager,
  rsbuildOptions,
  bundlerConfigs,
  inspectOptions = {}
}) {
  if (inspectOptions.mode) {
    setNodeEnv(inspectOptions.mode);
  } else if (!getNodeEnv()) {
    setNodeEnv("development");
  }
  const rspackConfigs = bundlerConfigs || (await initConfigs({
    context,
    pluginManager,
    rsbuildOptions
  })).rspackConfigs;
  const rawBundlerConfigs = rspackConfigs.map((config, index) => ({
    name: config.name || String(index),
    content: stringifyConfig(config, inspectOptions.verbose)
  }));
  const {
    rsbuildConfig,
    rawRsbuildConfig,
    environmentConfigs,
    rawEnvironmentConfigs
  } = getRsbuildInspectConfig({
    normalizedConfig: context.normalizedConfig,
    inspectOptions,
    pluginManager
  });
  const outputPath = getInspectOutputPath(context, inspectOptions);
  if (inspectOptions.writeToDisk) {
    await outputInspectConfigFiles({
      rawBundlerConfigs,
      rawEnvironmentConfigs,
      inspectOptions: {
        ...inspectOptions,
        outputPath
      },
      configType: "rspack"
    });
  }
  return {
    rsbuildConfig: rawRsbuildConfig,
    environmentConfigs: rawEnvironmentConfigs.map((r) => r.content),
    bundlerConfigs: rawBundlerConfigs.map((r) => r.content),
    origin: {
      rsbuildConfig,
      environmentConfigs,
      bundlerConfigs: rspackConfigs
    }
  };
}
var import_node_path10, getInspectOutputPath;
var init_inspectConfig = __esm({
  "src/provider/inspectConfig.ts"() {
    "use strict";
    import_node_path10 = require("path");
    init_config();
    init_constants();
    init_helpers();
    init_initConfigs();
    getInspectOutputPath = (context, inspectOptions) => {
      if (inspectOptions.outputPath) {
        if ((0, import_node_path10.isAbsolute)(inspectOptions.outputPath)) {
          return inspectOptions.outputPath;
        }
        return (0, import_node_path10.join)(context.distPath, inspectOptions.outputPath);
      }
      return (0, import_node_path10.join)(context.distPath, RSBUILD_OUTPUTS_PATH);
    };
  }
});

// ../../node_modules/.pnpm/reduce-configs@1.0.0/node_modules/reduce-configs/dist/index.js
function reduceConfigs({
  initial,
  config,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject2(config)) {
    return isPlainObject2(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction2(config)) {
    return config(initial) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigs({ initial: initial2, config: config2, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
function reduceConfigsWithContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject2(config)) {
    return isPlainObject2(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction2(config)) {
    return config(initial, ctx) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsWithContext({ initial: initial2, config: config2, ctx, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
async function reduceConfigsAsyncWithContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject2(config)) {
    return isPlainObject2(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction2(config)) {
    return await config(initial, ctx) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsWithContext({ initial: initial2, config: config2, ctx, mergeFn }),
      initial
    );
  }
  return config ?? initial;
}
function reduceConfigsMergeContext({
  initial,
  config,
  ctx,
  mergeFn = Object.assign
}) {
  if (isNil(config)) {
    return initial;
  }
  if (isPlainObject2(config)) {
    return isPlainObject2(initial) ? mergeFn(initial, config) : config;
  }
  if (isFunction2(config)) {
    return config({ value: initial, ...ctx }) ?? initial;
  }
  if (Array.isArray(config)) {
    return config.reduce(
      (initial2, config2) => reduceConfigsMergeContext({
        initial: initial2,
        config: config2,
        ctx,
        mergeFn
      }),
      initial
    );
  }
  return config ?? initial;
}
var isNil, isFunction2, isObject2, isPlainObject2;
var init_dist = __esm({
  "../../node_modules/.pnpm/reduce-configs@1.0.0/node_modules/reduce-configs/dist/index.js"() {
    "use strict";
    isNil = (o) => o === void 0 || o === null;
    isFunction2 = (func) => typeof func === "function";
    isObject2 = (obj) => obj !== null && typeof obj === "object";
    isPlainObject2 = (obj) => isObject2(obj) && Object.prototype.toString.call(obj) === "[object Object]";
  }
});

// src/configChain.ts
function getBundlerChain() {
  const bundlerChain = new import_rspack_chain2.default();
  return bundlerChain;
}
async function modifyBundlerChain(context, utils) {
  import_rslog.logger.debug("modify bundler chain");
  const bundlerChain = getBundlerChain();
  const [modifiedBundlerChain] = await context.hooks.modifyBundlerChain.callInEnvironment({
    environment: utils.environment.name,
    args: [bundlerChain, utils]
  });
  if (utils.environment.config.tools?.bundlerChain) {
    for (const item of castArray(utils.environment.config.tools.bundlerChain)) {
      await item(modifiedBundlerChain, utils);
    }
  }
  import_rslog.logger.debug("modify bundler chain done");
  return modifiedBundlerChain;
}
function chainToConfig(chain) {
  const config = chain.toConfig();
  const { entry } = config;
  if (!isPlainObject(entry)) {
    return config;
  }
  const formattedEntry = {};
  for (const [entryName, entryValue] of Object.entries(entry)) {
    const entryImport = [];
    let entryDescription = null;
    for (const item of castArray(entryValue)) {
      if (typeof item === "string") {
        entryImport.push(item);
        continue;
      }
      if (item.import) {
        entryImport.push(...castArray(item.import));
      }
      if (entryDescription) {
        Object.assign(entryDescription, item);
      } else {
        entryDescription = item;
      }
    }
    formattedEntry[entryName] = entryDescription ? {
      ...entryDescription,
      import: entryImport
    } : entryImport;
  }
  config.entry = formattedEntry;
  return config;
}
var import_rspack_chain2, CHAIN_ID;
var init_configChain = __esm({
  "src/configChain.ts"() {
    "use strict";
    import_rspack_chain2 = __toESM(require("../compiled/rspack-chain/index.js"));
    init_helpers();
    init_logger();
    CHAIN_ID = {
      /** Predefined rules */
      RULE: {
        /** Rule for .mjs */
        MJS: "mjs",
        /** Rule for fonts */
        FONT: "font",
        /** Rule for images */
        IMAGE: "image",
        /** Rule for media */
        MEDIA: "media",
        /** Rule for js */
        JS: "js",
        /** Rule for data uri encoded javascript */
        JS_DATA_URI: "js-data-uri",
        /** Rule for ts */
        TS: "ts",
        /** Rule for css */
        CSS: "css",
        /** Rule for less */
        LESS: "less",
        /** Rule for sass */
        SASS: "sass",
        /** Rule for stylus */
        STYLUS: "stylus",
        /** Rule for svg */
        SVG: "svg",
        /** Rule for pug */
        PUG: "pug",
        /** Rule for Vue */
        VUE: "vue",
        // TODO: remove
        /** Rule for yaml */
        YAML: "yaml",
        /** Rule for wasm */
        WASM: "wasm",
        /** Rule for svelte */
        SVELTE: "svelte"
      },
      /** Predefined rule groups */
      ONE_OF: {
        SVG: "svg",
        SVG_URL: "svg-asset-url",
        SVG_ASSET: "svg-asset",
        SVG_REACT: "svg-react",
        SVG_INLINE: "svg-asset-inline"
      },
      /** Predefined loaders */
      USE: {
        /** ts-loader */
        TS: "ts",
        /** css-loader */
        CSS: "css",
        /** sass-loader */
        SASS: "sass",
        /** less-loader */
        LESS: "less",
        /** stylus-loader */
        STYLUS: "stylus",
        /** url-loader */
        URL: "url",
        /** pug-loader */
        PUG: "pug",
        /** vue-loader */
        VUE: "vue",
        /** swc-loader */
        SWC: "swc",
        /** svgr */
        SVGR: "svgr",
        // TODO: remove
        /** yaml-loader */
        YAML: "yaml",
        /** babel-loader */
        BABEL: "babel",
        /** style-loader */
        STYLE: "style-loader",
        /** svelte-loader */
        SVELTE: "svelte",
        /** postcss-loader */
        POSTCSS: "postcss",
        /** lightningcss-loader */
        LIGHTNINGCSS: "lightningcss",
        /** ignore-css-loader */
        IGNORE_CSS: "ignore-css",
        /** css-modules-typescript-loader */
        CSS_MODULES_TS: "css-modules-typescript",
        /** CssExtractRspackPlugin.loader */
        MINI_CSS_EXTRACT: "mini-css-extract",
        /** resolve-url-loader */
        RESOLVE_URL: "resolve-url-loader"
      },
      /** Predefined plugins */
      PLUGIN: {
        /** HotModuleReplacementPlugin */
        HMR: "hmr",
        /** CopyRspackPlugin */
        COPY: "copy",
        /** HtmlRspackPlugin */
        HTML: "html",
        // TODO: remove
        /** ESLintWebpackPlugin */
        ESLINT: "eslint",
        /** DefinePlugin */
        DEFINE: "define",
        /** ProgressPlugin */
        PROGRESS: "progress",
        /** WebpackManifestPlugin */
        MANIFEST: "webpack-manifest",
        /** ForkTsCheckerWebpackPlugin */
        TS_CHECKER: "ts-checker",
        /** WebpackBundleAnalyzer */
        BUNDLE_ANALYZER: "bundle-analyze",
        /** ModuleFederationPlugin */
        MODULE_FEDERATION: "module-federation",
        /** htmlPrefetchPlugin */
        HTML_PREFETCH: "html-prefetch-plugin",
        /** htmlPreloadPlugin */
        HTML_PRELOAD: "html-preload-plugin",
        /** CssExtractRspackPlugin */
        MINI_CSS_EXTRACT: "mini-css-extract",
        /** VueLoaderPlugin */
        VUE_LOADER_PLUGIN: "vue-loader-plugin",
        /** ReactFastRefreshPlugin */
        REACT_FAST_REFRESH: "react-fast-refresh",
        // TODO: remove
        /** ProvidePlugin for node polyfill */
        NODE_POLYFILL_PROVIDE: "node-polyfill-provide",
        /** WebpackSRIPlugin */
        SUBRESOURCE_INTEGRITY: "subresource-integrity",
        /** AutoSetRootFontSizePlugin */
        AUTO_SET_ROOT_SIZE: "auto-set-root-size"
      },
      /** Predefined minimizers */
      MINIMIZER: {
        /** SwcJsMinimizerRspackPlugin */
        JS: "js",
        /** LightningCssMinimizerRspackPlugin */
        CSS: "css"
      },
      /** Predefined resolve plugins */
      RESOLVE_PLUGIN: {
        /** TsConfigPathsPlugin */
        TS_CONFIG_PATHS: "ts-config-paths"
      }
    };
  }
});

// src/provider/rspackConfig.ts
async function modifyRspackConfig(context, rspackConfig, utils) {
  import_rslog.logger.debug("modify Rspack config");
  let [modifiedConfig] = await context.hooks.modifyRspackConfig.callInEnvironment({
    environment: utils.environment.name,
    args: [rspackConfig, utils]
  });
  if (utils.environment.config.tools?.rspack) {
    modifiedConfig = await reduceConfigsAsyncWithContext({
      initial: modifiedConfig,
      config: utils.environment.config.tools.rspack,
      ctx: utils,
      mergeFn: utils.mergeConfig
    });
  }
  import_rslog.logger.debug("modify Rspack config done");
  return modifiedConfig;
}
async function getConfigUtils(config, chainUtils) {
  const { merge: merge2 } = await import("../compiled/webpack-merge/index.js");
  return {
    ...chainUtils,
    rspack: import_core2.rspack,
    mergeConfig: merge2,
    addRules(rules) {
      const ruleArr = castArray(rules);
      if (!config.module) {
        config.module = {};
      }
      if (!config.module.rules) {
        config.module.rules = [];
      }
      config.module.rules.unshift(...ruleArr);
    },
    prependPlugins(plugins) {
      const pluginArr = castArray(plugins);
      if (!config.plugins) {
        config.plugins = [];
      }
      config.plugins.unshift(...pluginArr);
    },
    appendPlugins(plugins) {
      const pluginArr = castArray(plugins);
      if (!config.plugins) {
        config.plugins = [];
      }
      config.plugins.push(...pluginArr);
    },
    removePlugin(pluginName) {
      if (!config.plugins) {
        return;
      }
      config.plugins = config.plugins.filter((plugin) => {
        if (!plugin) {
          return true;
        }
        const name = plugin.name || plugin.constructor.name;
        return name !== pluginName;
      });
    }
  };
}
function getChainUtils(target, environment) {
  const nodeEnv = getNodeEnv();
  return {
    environment,
    env: nodeEnv,
    target,
    isDev: environment.config.mode === "development",
    isProd: environment.config.mode === "production",
    isServer: target === "node",
    isWebWorker: target === "web-worker",
    CHAIN_ID,
    HtmlPlugin: getHTMLPlugin()
  };
}
async function generateRspackConfig({
  target,
  context,
  environment
}) {
  const chainUtils = getChainUtils(target, context.environments[environment]);
  const {
    BannerPlugin,
    DefinePlugin,
    IgnorePlugin,
    ProvidePlugin,
    HotModuleReplacementPlugin
  } = import_core2.rspack;
  const chain = await modifyBundlerChain(context, {
    ...chainUtils,
    bundler: {
      BannerPlugin,
      DefinePlugin,
      IgnorePlugin,
      ProvidePlugin,
      HotModuleReplacementPlugin
    }
  });
  let rspackConfig = chainToConfig(chain);
  rspackConfig = await modifyRspackConfig(
    context,
    rspackConfig,
    await getConfigUtils(rspackConfig, chainUtils)
  );
  return rspackConfig;
}
var import_core2;
var init_rspackConfig = __esm({
  "src/provider/rspackConfig.ts"() {
    "use strict";
    import_core2 = require("@rspack/core");
    init_dist();
    init_configChain();
    init_helpers();
    init_logger();
    init_pluginHelper();
  }
});

// src/provider/initConfigs.ts
async function modifyRsbuildConfig(context) {
  import_rslog.logger.debug("modify Rsbuild config");
  const [modified] = await context.hooks.modifyRsbuildConfig.call(
    context.config,
    { mergeRsbuildConfig }
  );
  context.config = modified;
  import_rslog.logger.debug("modify Rsbuild config done");
}
async function modifyEnvironmentConfig(context, config, name) {
  import_rslog.logger.debug(`modify Rsbuild environment(${name}) config`);
  const [modified] = await context.hooks.modifyEnvironmentConfig.callInEnvironment({
    environment: name,
    args: [
      config,
      {
        name,
        mergeEnvironmentConfig: mergeRsbuildConfig
      }
    ]
  });
  import_rslog.logger.debug(`modify Rsbuild environment(${name}) config done`);
  return modified;
}
async function initRsbuildConfig({
  context,
  pluginManager
}) {
  if (context.normalizedConfig) {
    return context.normalizedConfig;
  }
  await initPlugins({
    getPluginAPI: context.getPluginAPI,
    pluginManager
  });
  await modifyRsbuildConfig(context);
  const normalizeBaseConfig = normalizeConfig(context.config);
  const environments = {};
  const mergedEnvironments = initEnvironmentConfigs(
    normalizeBaseConfig,
    context.rootPath,
    context.specifiedEnvironments
  );
  const {
    dev: {
      hmr,
      assetPrefix,
      progressBar,
      lazyCompilation,
      ...rsbuildSharedDev
    },
    server
  } = normalizeBaseConfig;
  for (const [name, config] of Object.entries(mergedEnvironments)) {
    const environmentConfig = await modifyEnvironmentConfig(
      context,
      config,
      name
    );
    environments[name] = {
      ...environmentConfig,
      dev: {
        ...environmentConfig.dev,
        ...rsbuildSharedDev
      },
      server
    };
  }
  context.normalizedConfig = {
    ...normalizeBaseConfig,
    environments
  };
  await updateEnvironmentContext(context, environments);
  updateContextByNormalizedConfig(context);
  return context.normalizedConfig;
}
async function initConfigs({
  context,
  pluginManager,
  rsbuildOptions
}) {
  const normalizedConfig = await initRsbuildConfig({ context, pluginManager });
  const rspackConfigs = await Promise.all(
    Object.entries(normalizedConfig.environments).map(
      ([environment, config]) => generateRspackConfig({
        target: config.output.target,
        context,
        environment
      })
    )
  );
  if (isDebug()) {
    const inspect = () => {
      const inspectOptions = {
        verbose: true,
        writeToDisk: true
      };
      inspectConfig({
        context,
        pluginManager,
        inspectOptions,
        rsbuildOptions,
        bundlerConfigs: rspackConfigs
      });
    };
    context.hooks.onBeforeBuild.tap(({ isFirstCompile }) => {
      if (isFirstCompile) {
        inspect();
      }
    });
    context.hooks.onAfterStartDevServer.tap(inspect);
  }
  return {
    rspackConfigs
  };
}
var import_picocolors7, initEnvironmentConfigs;
var init_initConfigs = __esm({
  "src/provider/initConfigs.ts"() {
    "use strict";
    import_picocolors7 = __toESM(require("../compiled/picocolors/index.js"));
    init_config();
    init_constants();
    init_createContext();
    init_helpers();
    init_logger();
    init_mergeConfig();
    init_pluginManager();
    init_inspectConfig();
    init_rspackConfig();
    initEnvironmentConfigs = (normalizedConfig, rootPath, specifiedEnvironments) => {
      let defaultEntry;
      const getDefaultEntryWithMemo = () => {
        if (!defaultEntry) {
          defaultEntry = getDefaultEntry(rootPath);
        }
        return defaultEntry;
      };
      const { environments, dev, server, provider, ...rsbuildSharedConfig } = normalizedConfig;
      const isEnvironmentEnabled = (name) => !specifiedEnvironments || specifiedEnvironments.includes(name);
      const applyEnvironmentDefaultConfig = (config) => {
        if (!config.source.entry || Object.keys(config.source.entry).length === 0) {
          config.source.entry = getDefaultEntryWithMemo();
        }
        const isServer = config.output.target === "node";
        if (config.output.distPath.js === void 0) {
          config.output.distPath.js = isServer ? "" : JS_DIST_DIR;
        }
        return config;
      };
      if (environments && Object.keys(environments).length) {
        const resolvedEnvironments = Object.fromEntries(
          Object.entries(environments).filter(([name]) => isEnvironmentEnabled(name)).map(([name, config]) => {
            const environmentConfig = {
              ...mergeRsbuildConfig(
                {
                  ...rsbuildSharedConfig,
                  dev: pick(dev, [
                    "hmr",
                    "assetPrefix",
                    "progressBar",
                    "lazyCompilation"
                  ])
                },
                config
              )
            };
            return [name, applyEnvironmentDefaultConfig(environmentConfig)];
          })
        );
        if (!Object.keys(resolvedEnvironments).length) {
          throw new Error(
            `The current build is specified to run only in the ${import_picocolors7.default.yellow(specifiedEnvironments?.join(","))} environment, but the configuration of the specified environment was not found.`
          );
        }
        return resolvedEnvironments;
      }
      const defaultEnvironmentName = camelCase(rsbuildSharedConfig.output.target);
      if (!isEnvironmentEnabled(defaultEnvironmentName)) {
        throw new Error(
          `The current build is specified to run only in the ${import_picocolors7.default.yellow(specifiedEnvironments?.join(","))} environment, but the configuration of the specified environment was not found.`
        );
      }
      return {
        [defaultEnvironmentName]: applyEnvironmentDefaultConfig({
          ...rsbuildSharedConfig,
          dev: pick(dev, ["hmr", "assetPrefix", "progressBar", "lazyCompilation"])
        })
      };
    };
  }
});

// src/provider/createCompiler.ts
var createCompiler_exports = {};
__export(createCompiler_exports, {
  createCompiler: () => createCompiler
});
async function createCompiler(options) {
  import_rslog.logger.debug("create compiler");
  const { context } = options;
  const { rspackConfigs } = await initConfigs(options);
  await context.hooks.onBeforeCreateCompiler.call({
    bundlerConfigs: rspackConfigs,
    environments: context.environments
  });
  if (!await isSatisfyRspackVersion(import_core3.rspack.rspackVersion)) {
    throw new Error(
      `The current Rspack version does not meet the requirements, the minimum supported version of Rspack is ${import_picocolors8.default.green(
        rspackMinVersion
      )}`
    );
  }
  const compiler = rspackConfigs.length === 1 ? (0, import_core3.rspack)(rspackConfigs[0]) : (0, import_core3.rspack)(rspackConfigs);
  let isVersionLogged = false;
  let isCompiling = false;
  const logRspackVersion = () => {
    if (!isVersionLogged) {
      import_rslog.logger.debug(`Use Rspack v${import_core3.rspack.rspackVersion}`);
      isVersionLogged = true;
    }
  };
  compiler.hooks.watchRun.tap("rsbuild:compiling", () => {
    logRspackVersion();
    if (!isCompiling) {
      import_rslog.logger.start("Compiling...");
    }
    isCompiling = true;
  });
  if (context.normalizedConfig?.mode === "production") {
    compiler.hooks.run.tap("rsbuild:run", logRspackVersion);
  }
  const done = (stats) => {
    const statsJson = stats.toJson({
      all: false,
      timings: true
    });
    const printTime = (c, index) => {
      if (c.time) {
        const time = prettyTime(c.time / 1e3);
        const { name } = rspackConfigs[index];
        const suffix = name ? import_picocolors8.default.gray(` (${name})`) : "";
        import_rslog.logger.ready(`Compiled in ${time}${suffix}`);
      }
    };
    if (!stats.hasErrors()) {
      if (statsJson.children) {
        statsJson.children.forEach((c, index) => {
          printTime(c, index);
        });
      } else {
        printTime(statsJson, 0);
      }
    }
    const { message, level } = formatStats(stats, getStatsOptions(compiler));
    if (level === "error") {
      import_rslog.logger.error(message);
    }
    if (level === "warning") {
      import_rslog.logger.warn(message);
    }
    isCompiling = false;
  };
  compiler.hooks.done.tap(
    "rsbuild:done",
    (stats) => {
      done(stats);
    }
  );
  if (context.normalizedConfig?.mode === "development") {
    registerDevHook({
      context,
      compiler,
      bundlerConfigs: rspackConfigs,
      MultiStatsCtor: import_core3.rspack.MultiStats
    });
  }
  await context.hooks.onAfterCreateCompiler.call({
    compiler,
    environments: context.environments
  });
  import_rslog.logger.debug("create compiler done");
  return {
    compiler,
    rspackConfigs
  };
}
var import_core3, import_picocolors8;
var init_createCompiler = __esm({
  "src/provider/createCompiler.ts"() {
    "use strict";
    import_core3 = require("@rspack/core");
    import_picocolors8 = __toESM(require("../compiled/picocolors/index.js"));
    init_helpers();
    init_hooks();
    init_logger();
    init_initConfigs();
  }
});

// src/server/runner/asModule.ts
var import_node_vm, SYNTHETIC_MODULES_STORE, asModule;
var init_asModule = __esm({
  "src/server/runner/asModule.ts"() {
    "use strict";
    import_node_vm = __toESM(require("vm"));
    SYNTHETIC_MODULES_STORE = "__SYNTHETIC_MODULES_STORE";
    asModule = async (something, context, unlinked) => {
      if (something instanceof import_node_vm.default.Module) {
        return something;
      }
      context[SYNTHETIC_MODULES_STORE] = context[SYNTHETIC_MODULES_STORE] || [];
      const i = context[SYNTHETIC_MODULES_STORE].length;
      context[SYNTHETIC_MODULES_STORE].push(something);
      const code = [.../* @__PURE__ */ new Set(["default", ...Object.keys(something)])].map(
        (name) => `const _${name} = ${SYNTHETIC_MODULES_STORE}[${i}]${name === "default" ? "" : `[${JSON.stringify(name)}]`}; export { _${name} as ${name}};`
      ).join("\n");
      const m = new import_node_vm.default.SourceTextModule(code, {
        context
      });
      if (unlinked)
        return m;
      await m.link(() => {
      });
      if (m.instantiate)
        m.instantiate();
      await m.evaluate();
      return m;
    };
  }
});

// src/server/runner/basic.ts
var import_node_path11, isRelativePath, getSubPath, BasicRunner;
var init_basic = __esm({
  "src/server/runner/basic.ts"() {
    "use strict";
    import_node_path11 = __toESM(require("path"));
    isRelativePath = (p) => /^\.\.?\//.test(p);
    getSubPath = (p) => {
      const lastSlash = p.lastIndexOf("/");
      let firstSlash = p.indexOf("/");
      if (lastSlash !== -1 && firstSlash !== lastSlash) {
        if (firstSlash !== -1) {
          let next = p.indexOf("/", firstSlash + 1);
          let dir = p.slice(firstSlash + 1, next);
          while (dir === ".") {
            firstSlash = next;
            next = p.indexOf("/", firstSlash + 1);
            dir = p.slice(firstSlash + 1, next);
          }
        }
        return p.slice(firstSlash + 1, lastSlash + 1);
      }
      return "";
    };
    BasicRunner = class {
      constructor(_options) {
        this._options = _options;
        __publicField(this, "globalContext", null);
        __publicField(this, "baseModuleScope", null);
        __publicField(this, "requirers", /* @__PURE__ */ new Map());
      }
      run(file) {
        if (!this.globalContext) {
          this.globalContext = this.createGlobalContext();
        }
        this.baseModuleScope = this.createBaseModuleScope();
        this.createRunner();
        const res = this.getRequire()(
          this._options.dist,
          file.startsWith("./") ? file : `./${file}`
        );
        if (typeof res === "object" && "then" in res) {
          return res;
        }
        return Promise.resolve(res);
      }
      getRequire() {
        const entryRequire = this.requirers.get("entry");
        return (currentDirectory, modulePath, context = {}) => {
          const p = Array.isArray(modulePath) ? modulePath : modulePath.split("?")[0];
          return entryRequire(currentDirectory, p, context);
        };
      }
      getFile(modulePath, currentDirectory) {
        if (Array.isArray(modulePath)) {
          return {
            path: import_node_path11.default.join(currentDirectory, ".array-require.js"),
            content: `module.exports = (${modulePath.map((arg) => {
              return `require(${JSON.stringify(`./${arg}`)})`;
            }).join(", ")});`,
            subPath: ""
          };
        }
        if (isRelativePath(modulePath)) {
          const p = import_node_path11.default.join(currentDirectory, modulePath);
          return {
            path: p,
            content: this._options.readFileSync(p),
            subPath: getSubPath(modulePath)
          };
        }
        return null;
      }
      preExecute(_code, _file) {
      }
      postExecute(_m, _file) {
      }
      createRunner() {
        this.requirers.set(
          "entry",
          (_currentDirectory, _modulePath, _context = {}) => {
            throw new Error("Not implement");
          }
        );
      }
    };
  }
});

// src/server/runner/cjs.ts
var import_node_path12, import_node_vm2, define, CommonJsRunner;
var init_cjs = __esm({
  "src/server/runner/cjs.ts"() {
    "use strict";
    import_node_path12 = __toESM(require("path"));
    import_node_vm2 = __toESM(require("vm"));
    init_basic();
    define = (...args) => {
      const factory = args.pop();
      factory();
    };
    CommonJsRunner = class extends BasicRunner {
      createGlobalContext() {
        return {
          console,
          setTimeout: (cb, ms, ...args) => {
            const timeout = setTimeout(cb, ms, ...args);
            timeout.unref();
            return timeout;
          },
          clearTimeout
        };
      }
      createBaseModuleScope() {
        const baseModuleScope = {
          console: this.globalContext.console,
          setTimeout: this.globalContext.setTimeout,
          clearTimeout: this.globalContext.clearTimeout,
          nsObj: (m) => {
            Object.defineProperty(m, Symbol.toStringTag, {
              value: "Module"
            });
            return m;
          }
        };
        return baseModuleScope;
      }
      createModuleScope(requireFn, m, file) {
        return {
          ...this.baseModuleScope,
          require: requireFn.bind(null, import_node_path12.default.dirname(file.path)),
          module: m,
          exports: m.exports,
          __dirname: import_node_path12.default.dirname(file.path),
          __filename: file.path,
          define
        };
      }
      createRunner() {
        this.requirers.set("miss", this.createMissRequirer());
        this.requirers.set("entry", this.createCjsRequirer());
      }
      createMissRequirer() {
        return (_currentDirectory, modulePath, _context = {}) => {
          const modulePathStr = modulePath;
          return modulePathStr.startsWith("node:") ? require(modulePathStr.slice(5)) : require(modulePathStr);
        };
      }
      createCjsRequirer() {
        const requireCache = /* @__PURE__ */ Object.create(null);
        return (currentDirectory, modulePath, context = {}) => {
          const file = context.file || this.getFile(modulePath, currentDirectory);
          if (!file) {
            return this.requirers.get("miss")(currentDirectory, modulePath);
          }
          if (file.path in requireCache) {
            return requireCache[file.path].exports;
          }
          const m = {
            exports: {}
          };
          requireCache[file.path] = m;
          const currentModuleScope = this.createModuleScope(
            this.getRequire(),
            m,
            file
          );
          const args = Object.keys(currentModuleScope);
          const argValues = args.map((arg) => currentModuleScope[arg]);
          const code = `(function(${args.join(", ")}) {
        ${file.content}
      })`;
          this.preExecute(code, file);
          const fn = this._options.runInNewContext ? import_node_vm2.default.runInNewContext(code, this.globalContext, file.path) : import_node_vm2.default.runInThisContext(code, file.path);
          fn.call(m.exports, ...argValues);
          this.postExecute(m, file);
          return m.exports;
        };
      }
    };
  }
});

// src/server/runner/type.ts
var init_type = __esm({
  "src/server/runner/type.ts"() {
    "use strict";
  }
});

// src/server/runner/esm.ts
var import_node_path13, import_node_url, import_node_vm3, EsmRunner;
var init_esm = __esm({
  "src/server/runner/esm.ts"() {
    "use strict";
    import_node_path13 = __toESM(require("path"));
    import_node_url = require("url");
    import_node_vm3 = __toESM(require("vm"));
    init_asModule();
    init_cjs();
    init_type();
    EsmRunner = class extends CommonJsRunner {
      createRunner() {
        super.createRunner();
        this.requirers.set("cjs", this.getRequire());
        this.requirers.set("esm", this.createEsmRequirer());
        this.requirers.set("entry", (currentDirectory, modulePath, context) => {
          const file = this.getFile(modulePath, currentDirectory);
          if (!file) {
            return this.requirers.get("miss")(currentDirectory, modulePath);
          }
          if (file.path.endsWith(".mjs") && this._options.compilerOptions.experiments?.outputModule) {
            return this.requirers.get("esm")(currentDirectory, modulePath, {
              ...context,
              file
            });
          }
          return this.requirers.get("cjs")(currentDirectory, modulePath, {
            ...context,
            file
          });
        });
      }
      createEsmRequirer() {
        const esmContext = import_node_vm3.default.createContext(this.baseModuleScope, {
          name: "context for esm"
        });
        const esmCache = /* @__PURE__ */ new Map();
        const esmIdentifier = this._options.name;
        return (currentDirectory, modulePath, context = {}) => {
          if (!import_node_vm3.default.SourceTextModule) {
            throw new Error(
              "Running esm bundle needs add Node.js option '--experimental-vm-modules'."
            );
          }
          const _require = this.getRequire();
          const file = context.file || this.getFile(modulePath, currentDirectory);
          if (!file) {
            return this.requirers.get("miss")(currentDirectory, modulePath);
          }
          let esm = esmCache.get(file.path);
          if (!esm) {
            esm = new import_node_vm3.default.SourceTextModule(file.content, {
              identifier: `${esmIdentifier}-${file.path}`,
              // no attribute
              url: `${(0, import_node_url.pathToFileURL)(file.path).href}?${esmIdentifier}`,
              context: esmContext,
              initializeImportMeta: (meta, _) => {
                meta.url = (0, import_node_url.pathToFileURL)(file.path).href;
              },
              importModuleDynamically: async (specifier, module2) => {
                const result = await _require(import_node_path13.default.dirname(file.path), specifier, {
                  esmMode: 1 /* Evaluated */
                });
                return await asModule(result, module2.context);
              }
            });
            esmCache.set(file.path, esm);
          }
          if (context.esmMode === 2 /* Unlinked */)
            return esm;
          return (async () => {
            await esm.link(async (specifier, referencingModule) => {
              return await asModule(
                await _require(
                  import_node_path13.default.dirname(
                    referencingModule.identifier ? referencingModule.identifier.slice(esmIdentifier.length + 1) : (0, import_node_url.fileURLToPath)(referencingModule.url)
                  ),
                  specifier,
                  {
                    esmMode: 2 /* Unlinked */
                  }
                ),
                referencingModule.context,
                true
              );
            });
            if (esm.instantiate)
              esm.instantiate();
            await esm.evaluate();
            if (context.esmMode === 1 /* Evaluated */) {
              return esm;
            }
            const ns = esm.namespace;
            return ns.default && ns.default instanceof Promise ? ns.default : ns;
          })();
        };
      }
    };
  }
});

// src/server/runner/index.ts
var BasicRunnerFactory, run;
var init_runner = __esm({
  "src/server/runner/index.ts"() {
    "use strict";
    init_esm();
    BasicRunnerFactory = class {
      constructor(name) {
        this.name = name;
      }
      create(compilerOptions, dist, readFileSync) {
        const runner = this.createRunner(compilerOptions, dist, readFileSync);
        return runner;
      }
      createRunner(compilerOptions, dist, readFileSync) {
        const runnerOptions = {
          name: this.name,
          dist,
          compilerOptions,
          readFileSync
        };
        if (compilerOptions.target === "web" || compilerOptions.target === "webworker") {
          throw new Error(
            `not support run ${compilerOptions.target} resource in rsbuild server`
          );
        }
        return new EsmRunner(runnerOptions);
      }
    };
    run = async (bundlePath, outputPath, compilerOptions, readFileSync) => {
      const runnerFactory = new BasicRunnerFactory(bundlePath);
      const runner = runnerFactory.create(
        compilerOptions,
        outputPath,
        readFileSync
      );
      const mod = runner.run(bundlePath);
      return mod;
    };
  }
});

// src/server/environment.ts
var import_node_path14, loadBundle, getTransformedHtml;
var init_environment = __esm({
  "src/server/environment.ts"() {
    "use strict";
    import_node_path14 = require("path");
    init_runner();
    loadBundle = async (stats, entryName, utils) => {
      const { chunks, entrypoints, outputPath } = stats.toJson({
        all: false,
        chunks: true,
        entrypoints: true,
        outputPath: true
      });
      if (!entrypoints?.[entryName]) {
        throw new Error(`can't find entry(${entryName})`);
      }
      const { chunks: entryChunks = [] } = entrypoints[entryName];
      const files = entryChunks.reduce((prev, entryChunkName) => {
        const chunk = chunks?.find(
          (chunk2) => chunk2.entry && chunk2.names?.includes(String(entryChunkName))
        );
        return chunk?.files ? prev.concat(chunk.files.filter((file) => !file.endsWith(".css"))) : prev;
      }, []);
      if (files.length === 0) {
        throw new Error(`can't get bundle by entryName(${entryName})`);
      }
      if (files.length > 1) {
        throw new Error(
          `only support load single entry chunk, but got ${files.length}: ${files.join(",")}`
        );
      }
      const res = await run(
        files[0],
        outputPath,
        stats.compilation.options,
        utils.readFileSync
      );
      return res;
    };
    getTransformedHtml = async (entryName, utils) => {
      const { htmlPaths, distPath } = utils.environment;
      const htmlPath = htmlPaths[entryName];
      if (!htmlPath) {
        throw new Error(`can't get html file by entryName(${entryName})`);
      }
      const fileName = (0, import_node_path14.join)(distPath, htmlPath);
      const fileContent = utils.readFileSync(fileName);
      return fileContent;
    };
  }
});

// src/server/middlewares.ts
var import_node_path15, import_node_url2, import_picocolors9, faviconFallbackMiddleware, getStatusCodeColor, getRequestLoggerMiddleware, notFoundMiddleware, isFileExists2, maybeHTMLRequest, getHtmlCompletionMiddleware, getHtmlFallbackMiddleware;
var init_middlewares = __esm({
  "src/server/middlewares.ts"() {
    "use strict";
    import_node_path15 = __toESM(require("path"));
    import_node_url2 = require("url");
    import_picocolors9 = __toESM(require("../compiled/picocolors/index.js"));
    init_logger();
    faviconFallbackMiddleware = (req, res, next) => {
      if (req.url === "/favicon.ico") {
        res.statusCode = 204;
        res.end();
      } else {
        next();
      }
    };
    getStatusCodeColor = (status) => {
      if (status >= 500) {
        return import_picocolors9.default.red;
      }
      if (status >= 400) {
        return import_picocolors9.default.yellow;
      }
      if (status >= 300) {
        return import_picocolors9.default.cyan;
      }
      if (status >= 200) {
        return import_picocolors9.default.green;
      }
      return (res) => res;
    };
    getRequestLoggerMiddleware = async () => {
      const { default: onFinished } = await import("../compiled/on-finished/index.js");
      return (req, res, next) => {
        const _startAt = process.hrtime();
        const logRequest = () => {
          const method = req.method;
          const url2 = req.originalUrl || req.url;
          const status = Number(res.statusCode);
          const statusColor = getStatusCodeColor(status);
          const endAt = process.hrtime();
          const totalTime = (endAt[0] - _startAt[0]) * 1e3 + (endAt[1] - _startAt[1]) * 1e-6;
          import_rslog.logger.debug(
            `${statusColor(status)} ${method} ${import_picocolors9.default.gray(url2)} ${import_picocolors9.default.gray(
              `${totalTime.toFixed(3)} ms`
            )}`
          );
        };
        onFinished(res, logRequest);
        next();
      };
    };
    notFoundMiddleware = (_req, res, _next) => {
      res.statusCode = 404;
      res.end();
    };
    isFileExists2 = async (filePath, outputFileSystem) => new Promise((resolve2) => {
      outputFileSystem.stat(filePath, (_error, stats) => {
        resolve2(stats?.isFile());
      });
    });
    maybeHTMLRequest = (req) => {
      if (
        // require headers and url
        !req.url || !req.headers || // only accept GET or HEAD
        req.method !== "GET" && req.method !== "HEAD"
      ) {
        return false;
      }
      const { accept } = req.headers;
      return typeof accept === "string" && (accept.includes("text/html") || accept.includes("*/*"));
    };
    getHtmlCompletionMiddleware = ({ distPath, callback, outputFileSystem }) => {
      return async (req, res, next) => {
        if (!maybeHTMLRequest(req)) {
          return next();
        }
        const url2 = req.url;
        let pathname;
        try {
          pathname = (0, import_node_url2.parse)(url2, false, true).pathname;
        } catch (err) {
          import_rslog.logger.error(
            new Error(`Invalid URL: ${import_picocolors9.default.yellow(url2)}`, { cause: err })
          );
          return next();
        }
        const rewrite = (newUrl) => {
          req.url = newUrl;
          return callback(req, res, (...args) => {
            next(...args);
          });
        };
        if (pathname.endsWith("/")) {
          const newUrl = `${pathname}index.html`;
          const filePath = import_node_path15.default.join(distPath, newUrl);
          if (await isFileExists2(filePath, outputFileSystem)) {
            return rewrite(newUrl);
          }
        } else if (!import_node_path15.default.extname(pathname)) {
          const newUrl = `${pathname}.html`;
          const filePath = import_node_path15.default.join(distPath, newUrl);
          if (await isFileExists2(filePath, outputFileSystem)) {
            return rewrite(newUrl);
          }
        }
        next();
      };
    };
    getHtmlFallbackMiddleware = ({ htmlFallback, distPath, callback, outputFileSystem }) => {
      return async (req, res, next) => {
        if (!maybeHTMLRequest(req) || "/favicon.ico" === req.url || htmlFallback !== "index") {
          return next();
        }
        const filePath = import_node_path15.default.join(distPath, "index.html");
        if (await isFileExists2(filePath, outputFileSystem)) {
          const newUrl = "/index.html";
          if (import_rslog.logger.level === "verbose") {
            import_rslog.logger.debug(
              `${req.method} ${import_picocolors9.default.gray(
                `${req.url} ${import_picocolors9.default.yellow("fallback")} to ${newUrl}`
              )}`
            );
          }
          req.url = newUrl;
          return callback(req, res, (...args) => next(...args));
        }
        next();
      };
    };
  }
});

// src/server/gzipMiddleware.ts
var gzipMiddleware_exports = {};
__export(gzipMiddleware_exports, {
  gzipMiddleware: () => gzipMiddleware
});
var import_node_zlib, ENCODING_REGEX, CONTENT_TYPE_REGEX, shouldCompress, gzipMiddleware;
var init_gzipMiddleware = __esm({
  "src/server/gzipMiddleware.ts"() {
    "use strict";
    import_node_zlib = __toESM(require("zlib"));
    ENCODING_REGEX = /\bgzip\b/;
    CONTENT_TYPE_REGEX = /text|javascript|\/json|xml/i;
    shouldCompress = (res) => {
      if (res.getHeader("Content-Encoding")) {
        return false;
      }
      const contentType = String(res.getHeader("Content-Type"));
      if (contentType && !CONTENT_TYPE_REGEX.test(contentType)) {
        return false;
      }
      const size = res.getHeader("Content-Length");
      return size === void 0 || Number(size) > 1024;
    };
    gzipMiddleware = ({
      level = import_node_zlib.default.constants.Z_BEST_SPEED
    } = {}) => (req, res, next) => {
      const accept = req.headers["accept-encoding"];
      const encoding = typeof accept === "string" && ENCODING_REGEX.test(accept);
      if (req.method === "HEAD" || !encoding) {
        next();
        return;
      }
      let gzip2;
      let writeHeadStatus;
      let started = false;
      const { end, write, on, writeHead } = res;
      const listeners = [];
      const start = () => {
        if (started) {
          return;
        }
        started = true;
        if (shouldCompress(res)) {
          res.setHeader("Content-Encoding", "gzip");
          res.removeHeader("Content-Length");
          gzip2 = import_node_zlib.default.createGzip({ level });
          gzip2.on("data", (chunk) => {
            if (write.call(res, chunk) === false) {
              gzip2.pause();
            }
          });
          on.call(res, "drain", () => gzip2.resume());
          gzip2.on("end", () => {
            end.call(res);
          });
          for (const listener of listeners) {
            gzip2.on.apply(gzip2, listener);
          }
        } else {
          for (const listener of listeners) {
            on.apply(res, listener);
          }
        }
        writeHead.call(res, writeHeadStatus ?? res.statusCode);
      };
      res.writeHead = (status, reason, headers) => {
        if (reason) {
          for (const [key, value] of Object.entries(headers || reason)) {
            res.setHeader(key, value);
          }
        }
        writeHeadStatus = status;
        return res;
      };
      res.write = (...args) => {
        start();
        return gzip2 ? gzip2.write(...args) : write.apply(res, args);
      };
      res.end = (...args) => {
        start();
        return gzip2 ? gzip2.end(...args) : end.apply(res, args);
      };
      res.on = (type, listener) => {
        if (started) {
          if (!gzip2 || type !== "drain") {
            on.call(res, type, listener);
          } else {
            gzip2.on(type, listener);
          }
        } else {
          listeners.push([type, listener]);
        }
        return res;
      };
      next();
    };
  }
});

// src/server/proxy.ts
var proxy_exports = {};
__export(proxy_exports, {
  createProxyMiddleware: () => createProxyMiddleware
});
function formatProxyOptions(proxyOptions) {
  const ret = [];
  if (Array.isArray(proxyOptions)) {
    ret.push(...proxyOptions);
  } else if ("target" in proxyOptions) {
    ret.push(proxyOptions);
  } else {
    for (const [context, options] of Object.entries(proxyOptions)) {
      const opts = {
        context,
        changeOrigin: true,
        logLevel: "warn"
      };
      if (typeof options === "string") {
        opts.target = options;
      } else {
        Object.assign(opts, options);
      }
      ret.push(opts);
    }
  }
  const handleError = (err) => import_rslog.logger.error(err);
  for (const opts of ret) {
    opts.onError ??= handleError;
  }
  return ret;
}
var createProxyMiddleware;
var init_proxy = __esm({
  "src/server/proxy.ts"() {
    "use strict";
    init_logger();
    createProxyMiddleware = async (proxyOptions) => {
      const formattedOptions = formatProxyOptions(proxyOptions);
      const proxyMiddlewares = [];
      const middlewares = [];
      const { createProxyMiddleware: baseMiddleware } = await import("../compiled/http-proxy-middleware/index.js");
      for (const opts of formattedOptions) {
        const proxyMiddleware = baseMiddleware(opts.context, opts);
        const middleware = async (req, res, next) => {
          const bypassUrl = typeof opts.bypass === "function" ? opts.bypass(req, res, opts) : null;
          if (bypassUrl === false) {
            res.statusCode = 404;
            next();
          } else if (typeof bypassUrl === "string") {
            req.url = bypassUrl;
            next();
          } else if (bypassUrl === true) {
            next();
          } else {
            proxyMiddleware(req, res, next);
          }
        };
        middlewares.push(middleware);
        opts.ws && proxyMiddlewares.push(proxyMiddleware);
      }
      const handleUpgrade = (req, socket, head) => {
        for (const middleware of proxyMiddlewares) {
          if (typeof middleware.upgrade === "function") {
            middleware.upgrade(req, socket, head);
          }
        }
      };
      return {
        middlewares,
        upgrade: handleUpgrade
      };
    };
  }
});

// src/server/getDevMiddlewares.ts
var import_node_path16, import_node_url3, applySetupMiddlewares, applyDefaultMiddlewares, getMiddlewares;
var init_getDevMiddlewares = __esm({
  "src/server/getDevMiddlewares.ts"() {
    "use strict";
    import_node_path16 = require("path");
    import_node_url3 = __toESM(require("url"));
    init_config();
    init_logger();
    init_middlewares();
    applySetupMiddlewares = (dev, environments, compileMiddlewareAPI) => {
      const setupMiddlewares = dev.setupMiddlewares || [];
      const serverOptions = {
        sockWrite: (type, data) => compileMiddlewareAPI?.sockWrite(type, data),
        environments
      };
      const before = [];
      const after = [];
      for (const handler of setupMiddlewares) {
        handler(
          {
            unshift: (...handlers) => before.unshift(...handlers),
            push: (...handlers) => after.push(...handlers)
          },
          serverOptions
        );
      }
      return { before, after };
    };
    applyDefaultMiddlewares = async ({
      middlewares,
      server,
      compileMiddlewareAPI,
      output,
      pwd,
      outputFileSystem
    }) => {
      const upgradeEvents = [];
      if (server.compress) {
        const { gzipMiddleware: gzipMiddleware2 } = await Promise.resolve().then(() => (init_gzipMiddleware(), gzipMiddleware_exports));
        middlewares.push(gzipMiddleware2());
      }
      middlewares.push((req, res, next) => {
        res.setHeader("Access-Control-Allow-Origin", "*");
        const path20 = req.url ? import_node_url3.default.parse(req.url).pathname : "";
        if (path20?.includes("hot-update")) {
          res.setHeader("Access-Control-Allow-Credentials", "false");
        }
        const confHeaders = server.headers;
        if (confHeaders) {
          for (const [key, value] of Object.entries(confHeaders)) {
            res.setHeader(key, value);
          }
        }
        next();
      });
      if (server.proxy) {
        const { createProxyMiddleware: createProxyMiddleware2 } = await Promise.resolve().then(() => (init_proxy(), proxy_exports));
        const { middlewares: proxyMiddlewares, upgrade } = await createProxyMiddleware2(server.proxy);
        upgradeEvents.push(upgrade);
        for (const middleware of proxyMiddlewares) {
          middlewares.push(middleware);
        }
      }
      const { default: launchEditorMiddleware } = await import("../compiled/launch-editor-middleware/index.js");
      middlewares.push(["/__open-in-editor", launchEditorMiddleware()]);
      if (compileMiddlewareAPI) {
        middlewares.push(compileMiddlewareAPI.middleware);
        upgradeEvents.push(
          compileMiddlewareAPI.onUpgrade.bind(compileMiddlewareAPI)
        );
        middlewares.push((req, res, next) => {
          if (req.url?.endsWith(".hot-update.json") && req.method !== "OPTIONS") {
            res.statusCode = 404;
            res.end();
          } else {
            next();
          }
        });
      }
      const distPath = (0, import_node_path16.isAbsolute)(output.distPath) ? output.distPath : (0, import_node_path16.join)(pwd, output.distPath);
      if (compileMiddlewareAPI) {
        middlewares.push(
          getHtmlCompletionMiddleware({
            distPath,
            callback: compileMiddlewareAPI.middleware,
            outputFileSystem
          })
        );
      }
      const publicDirs = normalizePublicDirs(server?.publicDir);
      for (const publicDir of publicDirs) {
        const { default: sirv } = await import("../compiled/sirv/index.js");
        const { name } = publicDir;
        const normalizedPath = (0, import_node_path16.isAbsolute)(name) ? name : (0, import_node_path16.join)(pwd, name);
        const assetMiddleware = sirv(normalizedPath, {
          etag: true,
          dev: true
        });
        middlewares.push(assetMiddleware);
      }
      if (compileMiddlewareAPI) {
        middlewares.push(
          getHtmlFallbackMiddleware({
            distPath,
            callback: compileMiddlewareAPI.middleware,
            htmlFallback: server.htmlFallback,
            outputFileSystem
          })
        );
      }
      if (server.historyApiFallback) {
        const { default: connectHistoryApiFallback } = await import("../compiled/connect-history-api-fallback/index.js");
        const historyApiFallbackMiddleware = connectHistoryApiFallback(
          server.historyApiFallback === true ? {} : server.historyApiFallback
        );
        middlewares.push(historyApiFallbackMiddleware);
        compileMiddlewareAPI?.middleware && middlewares.push(compileMiddlewareAPI.middleware);
      }
      middlewares.push(faviconFallbackMiddleware);
      middlewares.push((req, res, next) => {
        if (req.method === "OPTIONS") {
          res.statusCode = 204;
          res.setHeader("Content-Length", "0");
          res.end();
          return;
        }
        next();
      });
      return {
        onUpgrade: (...args) => {
          for (const cb of upgradeEvents) {
            cb(...args);
          }
        }
      };
    };
    getMiddlewares = async (options) => {
      const middlewares = [];
      const { environments, compileMiddlewareAPI } = options;
      if (import_rslog.logger.level === "verbose") {
        middlewares.push(await getRequestLoggerMiddleware());
      }
      const { before, after } = applySetupMiddlewares(
        options.dev,
        environments,
        compileMiddlewareAPI
      );
      middlewares.push(...before);
      const { onUpgrade } = await applyDefaultMiddlewares({
        ...options,
        middlewares
      });
      middlewares.push(...after);
      return {
        close: async () => {
          compileMiddlewareAPI?.close();
        },
        onUpgrade,
        middlewares
      };
    };
  }
});

// src/server/helper.ts
function getURLMessages(urls, routes) {
  if (routes.length === 1) {
    return urls.map(
      ({ label, url: url2 }) => `  ${`> ${label.padEnd(10)}`}${import_picocolors10.default.cyan(
        normalizeUrl(`${url2}${routes[0].pathname}`)
      )}
`
    ).join("");
  }
  let message = "";
  const maxNameLength = Math.max(...routes.map((r) => r.entryName.length));
  urls.forEach(({ label, url: url2 }, index) => {
    if (index > 0) {
      message += "\n";
    }
    message += `  ${`> ${label}`}
`;
    for (const r of routes) {
      message += `  ${import_picocolors10.default.dim("-")} ${import_picocolors10.default.dim(
        r.entryName.padEnd(maxNameLength + 4)
      )}${import_picocolors10.default.cyan(normalizeUrl(`${url2}${r.pathname}`))}
`;
    }
  });
  return message;
}
function printServerURLs({
  urls: originalUrls,
  port,
  routes,
  protocol,
  printUrls
}) {
  if (printUrls === false) {
    return null;
  }
  let urls = originalUrls;
  if (isFunction(printUrls)) {
    const newUrls = printUrls({
      urls: urls.map((item) => item.url),
      port,
      routes,
      protocol
    });
    if (!newUrls) {
      return null;
    }
    if (!Array.isArray(newUrls)) {
      throw new Error(
        `"server.printUrls" must return an array, but got ${typeof newUrls}.`
      );
    }
    urls = newUrls.map((url2) => ({
      url: url2,
      label: getUrlLabel(url2)
    }));
  }
  if (urls.length === 0 || routes.length === 0) {
    return null;
  }
  const message = getURLMessages(urls, routes);
  import_rslog.logger.log(message);
  return message;
}
function getServerTerminator(server) {
  let listened = false;
  const pendingSockets = /* @__PURE__ */ new Set();
  const onConnection = (socket) => {
    pendingSockets.add(socket);
    socket.on("close", () => {
      pendingSockets.delete(socket);
    });
  };
  server.on("connection", onConnection);
  server.on("secureConnection", onConnection);
  server.once("listening", () => {
    listened = true;
  });
  return () => new Promise((resolve2, reject) => {
    for (const socket of pendingSockets) {
      socket.destroy();
    }
    if (listened) {
      server.close((err) => err ? reject(err) : resolve2());
    } else {
      resolve2();
    }
  });
}
var import_node_net, import_node_os, import_node_path17, import_picocolors10, normalizeUrl, formatPrefix, getRoutes, formatRoutes, getPort, getServerConfig, getIpv4Interfaces, isLoopbackHost, getHostInUrl, concatUrl, LOCAL_LABEL, NETWORK_LABEL, getUrlLabel, getAddressUrls, COMPILATION_ID_REGEX, getCompilationId;
var init_helper = __esm({
  "src/server/helper.ts"() {
    "use strict";
    import_node_net = __toESM(require("net"));
    import_node_os = __toESM(require("os"));
    import_node_path17 = require("path");
    import_picocolors10 = __toESM(require("../compiled/picocolors/index.js"));
    init_constants();
    init_helpers();
    init_logger();
    normalizeUrl = (url2) => url2.replace(/([^:]\/)\/+/g, "$1");
    formatPrefix = (input) => {
      let prefix = input;
      if (prefix?.startsWith("./")) {
        prefix = prefix.replace("./", "");
      }
      if (!prefix) {
        return "/";
      }
      const hasLeadingSlash = prefix.startsWith("/");
      const hasTailSlash = prefix.endsWith("/");
      return `${hasLeadingSlash ? "" : "/"}${prefix}${hasTailSlash ? "" : "/"}`;
    };
    getRoutes = (context) => {
      return Object.values(context.environments).reduce(
        (prev, environmentContext) => {
          const { distPath, config } = environmentContext;
          const distPrefix = import_node_path17.posix.relative(context.distPath, distPath);
          const routes = formatRoutes(
            environmentContext.htmlPaths,
            import_node_path17.posix.join(distPrefix, config.output.distPath.html),
            config.html.outputStructure
          );
          return prev.concat(...routes);
        },
        []
      );
    };
    formatRoutes = (entry, prefix, outputStructure) => {
      const formattedPrefix = formatPrefix(prefix);
      return Object.keys(entry).map((entryName) => {
        const isIndex = entryName === "index" && outputStructure !== "nested";
        const displayName = isIndex ? "" : entryName;
        return {
          entryName,
          pathname: formattedPrefix + displayName
        };
      }).sort((a) => a.entryName === "index" ? -1 : 1);
    };
    getPort = async ({
      host,
      port,
      strictPort,
      tryLimits = 20,
      silent = false
    }) => {
      if (typeof port === "string") {
        port = Number.parseInt(port, 10);
      }
      if (strictPort) {
        tryLimits = 1;
      }
      const original = port;
      let found = false;
      let attempts = 0;
      while (!found && attempts <= tryLimits) {
        try {
          await new Promise((resolve2, reject) => {
            const server = import_node_net.default.createServer();
            server.unref();
            server.on("error", reject);
            server.listen({ port, host }, () => {
              found = true;
              server.close(resolve2);
            });
          });
        } catch (e) {
          if (e.code !== "EADDRINUSE") {
            throw e;
          }
          port++;
          attempts++;
        }
      }
      if (port !== original) {
        if (strictPort) {
          throw new Error(
            `Port "${original}" is occupied, please choose another one.`
          );
        }
        if (!silent) {
          import_rslog.logger.info(
            `Port ${original} is in use, ${import_picocolors10.default.yellow(`using port ${port}.`)}
`
          );
        }
      }
      return port;
    };
    getServerConfig = async ({
      config,
      getPortSilently
    }) => {
      const host = config.server.host || DEFAULT_DEV_HOST;
      const port = await getPort({
        host,
        port: config.server.port || DEFAULT_PORT,
        strictPort: config.server.strictPort || false,
        silent: getPortSilently
      });
      const https = Boolean(config.server.https) || false;
      return { port, host, https };
    };
    getIpv4Interfaces = () => {
      const interfaces = import_node_os.default.networkInterfaces();
      const ipv4Interfaces = /* @__PURE__ */ new Map();
      for (const key of Object.keys(interfaces)) {
        for (const detail of interfaces[key]) {
          const familyV4Value = typeof detail.family === "string" ? "IPv4" : 4;
          if (detail.family === familyV4Value && !ipv4Interfaces.has(detail.address)) {
            ipv4Interfaces.set(detail.address, detail);
          }
        }
      }
      return Array.from(ipv4Interfaces.values());
    };
    isLoopbackHost = (host) => {
      const loopbackHosts = [
        "localhost",
        "127.0.0.1",
        "::1",
        "0000:0000:0000:0000:0000:0000:0000:0001"
      ];
      return loopbackHosts.includes(host);
    };
    getHostInUrl = (host) => {
      if (import_node_net.default.isIPv6(host)) {
        return host === "::" ? "[::1]" : `[${host}]`;
      }
      return host;
    };
    concatUrl = ({
      host,
      port,
      protocol
    }) => `${protocol}://${host}:${port}`;
    LOCAL_LABEL = "Local:  ";
    NETWORK_LABEL = "Network:  ";
    getUrlLabel = (url2) => {
      try {
        const { host } = new URL(url2);
        return isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL;
      } catch (err) {
        return NETWORK_LABEL;
      }
    };
    getAddressUrls = ({
      protocol = "http",
      port,
      host
    }) => {
      if (host && host !== DEFAULT_DEV_HOST) {
        return [
          {
            label: isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL,
            url: concatUrl({
              port,
              host: getHostInUrl(host),
              protocol
            })
          }
        ];
      }
      const ipv4Interfaces = getIpv4Interfaces();
      const addressUrls = [];
      let hasLocalUrl = false;
      for (const detail of ipv4Interfaces) {
        if (isLoopbackHost(detail.address) || detail.internal) {
          if (hasLocalUrl) {
            continue;
          }
          addressUrls.push({
            label: LOCAL_LABEL,
            url: concatUrl({ host: "localhost", port, protocol })
          });
          hasLocalUrl = true;
        } else {
          addressUrls.push({
            label: NETWORK_LABEL,
            url: concatUrl({ host: detail.address, port, protocol })
          });
        }
      }
      return addressUrls;
    };
    COMPILATION_ID_REGEX = /[^a-zA-Z0-9_-]/g;
    getCompilationId = (compiler) => {
      const uniqueName = compiler.options.output.uniqueName ?? "";
      return `${compiler.name ?? ""}_${uniqueName.replace(COMPILATION_ID_REGEX, "_")}`;
    };
  }
});

// src/server/httpServer.ts
var createHttpServer;
var init_httpServer = __esm({
  "src/server/httpServer.ts"() {
    "use strict";
    createHttpServer = async ({
      serverConfig,
      middlewares
    }) => {
      if (serverConfig.https) {
        if (serverConfig.proxy) {
          const { createServer: createServer2 } = await import("https");
          return createServer2(serverConfig.https, middlewares);
        }
        const { createSecureServer } = await import("http2");
        return createSecureServer(
          {
            allowHTTP1: true,
            // increase the maximum memory (MiB)
            maxSessionMemory: 1024,
            ...serverConfig.https
          },
          // @ts-expect-error req type mismatch
          middlewares
        );
      }
      const { createServer } = await import("http");
      return createServer(middlewares);
    };
  }
});

// src/server/watchFiles.ts
async function setupWatchFiles(options) {
  const { dev, server, compileMiddlewareAPI } = options;
  const { hmr, liveReload } = dev;
  if (!hmr && !liveReload || !compileMiddlewareAPI) {
    return;
  }
  const devFilesWatcher = await watchDevFiles(dev, compileMiddlewareAPI);
  const serverFilesWatcher = await watchServerFiles(
    server,
    compileMiddlewareAPI
  );
  return {
    async close() {
      await Promise.all([
        devFilesWatcher?.close(),
        serverFilesWatcher?.close()
      ]);
    }
  };
}
async function watchDevFiles(devConfig, compileMiddlewareAPI) {
  const { watchFiles: watchFiles2 } = devConfig;
  if (!watchFiles2) {
    return;
  }
  const watchOptions = prepareWatchOptions(
    watchFiles2.paths,
    watchFiles2.options,
    watchFiles2.type
  );
  return startWatchFiles(watchOptions, compileMiddlewareAPI);
}
function watchServerFiles(serverConfig, compileMiddlewareAPI) {
  const publicDirs = normalizePublicDirs(serverConfig.publicDir);
  if (!publicDirs.length) {
    return;
  }
  const watchPaths = publicDirs.filter((item) => item.watch).map((item) => item.name);
  if (!watchPaths.length) {
    return;
  }
  const watchOptions = prepareWatchOptions(watchPaths);
  return startWatchFiles(watchOptions, compileMiddlewareAPI);
}
function prepareWatchOptions(paths, options = {}, type) {
  return {
    paths: typeof paths === "string" ? [paths] : paths,
    options,
    type
  };
}
async function startWatchFiles({ paths, options, type }, compileMiddlewareAPI) {
  if (type === "reload-server") {
    return;
  }
  const chokidar = await import("../compiled/chokidar/index.js");
  const watcher = chokidar.watch(paths, options);
  watcher.on("change", () => {
    compileMiddlewareAPI.sockWrite("static-changed");
  });
  return watcher;
}
var init_watchFiles = __esm({
  "src/server/watchFiles.ts"() {
    "use strict";
    init_config();
  }
});

// src/server/devMiddleware.ts
function applyHMREntry({
  compiler,
  clientPaths,
  clientConfig = {},
  liveReload = true
}) {
  if (!isClientCompiler(compiler)) {
    return;
  }
  new compiler.webpack.DefinePlugin({
    RSBUILD_COMPILATION_NAME: JSON.stringify(getCompilationId(compiler)),
    RSBUILD_CLIENT_CONFIG: JSON.stringify(clientConfig),
    RSBUILD_DEV_LIVE_RELOAD: liveReload
  }).apply(compiler);
  for (const clientPath of clientPaths) {
    new compiler.webpack.EntryPlugin(compiler.context, clientPath, {
      name: void 0
    }).apply(compiler);
  }
}
var isClientCompiler, isNodeCompiler, setupServerHooks, getDevMiddleware;
var init_devMiddleware = __esm({
  "src/server/devMiddleware.ts"() {
    "use strict";
    init_helpers();
    init_helper();
    isClientCompiler = (compiler) => {
      const { target } = compiler.options;
      if (target) {
        return Array.isArray(target) ? target.includes("web") : target === "web";
      }
      return false;
    };
    isNodeCompiler = (compiler) => {
      const { target } = compiler.options;
      if (target) {
        return Array.isArray(target) ? target.includes("node") : target === "node";
      }
      return false;
    };
    setupServerHooks = (compiler, hookCallbacks) => {
      if (isNodeCompiler(compiler)) {
        return;
      }
      const { compile, invalid, done } = compiler.hooks;
      compile.tap(
        "rsbuild-dev-server",
        () => hookCallbacks.onInvalid(getCompilationId(compiler))
      );
      invalid.tap(
        "rsbuild-dev-server",
        () => hookCallbacks.onInvalid(getCompilationId(compiler))
      );
      done.tap("rsbuild-dev-server", hookCallbacks.onDone);
    };
    getDevMiddleware = async (multiCompiler) => {
      const { default: rsbuildDevMiddleware } = await import("../compiled/rsbuild-dev-middleware/index.js");
      return (options) => {
        const { clientPaths, clientConfig, callbacks, liveReload, ...restOptions } = options;
        const setupCompiler = (compiler) => {
          if (clientPaths) {
            applyHMREntry({
              compiler,
              clientPaths,
              clientConfig,
              liveReload
            });
          }
          setupServerHooks(compiler, callbacks);
        };
        applyToCompiler(multiCompiler, setupCompiler);
        return rsbuildDevMiddleware(multiCompiler, restOptions);
      };
    };
  }
});

// src/server/socketServer.ts
function isEqualSet(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const v of a.values()) {
    if (!b.has(v)) {
      return false;
    }
  }
  return true;
}
var import_node_querystring, SocketServer;
var init_socketServer = __esm({
  "src/server/socketServer.ts"() {
    "use strict";
    import_node_querystring = require("querystring");
    init_helpers();
    init_logger();
    init_helper();
    SocketServer = class {
      constructor(options) {
        __publicField(this, "wsServer");
        __publicField(this, "sockets", []);
        __publicField(this, "options");
        __publicField(this, "stats");
        __publicField(this, "initialChunks");
        __publicField(this, "timer", null);
        this.options = options;
        this.stats = {};
        this.initialChunks = {};
      }
      upgrade(req, sock, head) {
        if (!this.wsServer.shouldHandle(req)) {
          return;
        }
        this.wsServer.handleUpgrade(req, sock, head, (connection) => {
          this.wsServer.emit("connection", connection, req);
        });
      }
      // create socket, install socket handler, bind socket event
      async prepare() {
        const { default: ws } = await import("../compiled/ws/index.js");
        this.wsServer = new ws.Server({
          noServer: true,
          path: this.options.client?.path
        });
        this.wsServer.on("error", (err) => {
          import_rslog.logger.error(err);
        });
        this.timer = setInterval(() => {
          for (const socket of this.wsServer.clients) {
            const extWs = socket;
            if (!extWs.isAlive) {
              extWs.terminate();
            } else {
              extWs.isAlive = false;
              extWs.ping(() => {
              });
            }
          }
        }, 3e4);
        this.wsServer.on("connection", (socket, req) => {
          const queryStr = req.url ? req.url.split("?")[1] : "";
          this.onConnect(
            socket,
            queryStr ? (0, import_node_querystring.parse)(queryStr) : {}
          );
        });
      }
      updateStats(stats) {
        const compilationId = getCompilationId(stats.compilation);
        this.stats[compilationId] = stats;
        this.sendStats({
          compilationId
        });
      }
      // write message to each socket
      sockWrite({
        type,
        compilationId,
        data
      }) {
        for (const socket of this.sockets) {
          this.send(socket, JSON.stringify({ type, data, compilationId }));
        }
      }
      singleWrite(socket, {
        type,
        data,
        compilationId
      }) {
        this.send(socket, JSON.stringify({ type, data, compilationId }));
      }
      close() {
        for (const socket of this.sockets) {
          socket.close();
        }
        if (this.timer) {
          clearInterval(this.timer);
          this.timer = null;
        }
      }
      onConnect(socket, params) {
        const connection = socket;
        connection.isAlive = true;
        connection.on("pong", () => {
          connection.isAlive = true;
        });
        if (!connection) {
          return;
        }
        this.sockets.push(connection);
        connection.on("close", () => {
          const idx = this.sockets.indexOf(connection);
          if (idx >= 0) {
            this.sockets.splice(idx, 1);
          }
        });
        if (this.options.hmr || this.options.liveReload) {
          this.singleWrite(connection, {
            type: "hot",
            compilationId: params.compilationId
          });
        }
        if (this.stats) {
          this.sendStats({
            force: true,
            compilationId: params.compilationId
          });
        }
      }
      // get standard stats
      getStats(name) {
        const curStats = this.stats[name];
        if (!curStats) {
          return null;
        }
        const defaultStats = {
          all: false,
          hash: true,
          assets: true,
          warnings: true,
          warningsCount: true,
          errors: true,
          errorsCount: true,
          errorDetails: false,
          entrypoints: true,
          children: true
        };
        return curStats.toJson(defaultStats);
      }
      // determine what message should send by stats
      sendStats({
        force = false,
        compilationId
      }) {
        const stats = this.getStats(compilationId);
        if (!stats) {
          return null;
        }
        const newInitialChunks = /* @__PURE__ */ new Set();
        if (stats.entrypoints) {
          for (const entrypoint of Object.values(stats.entrypoints)) {
            const chunks = entrypoint.chunks;
            if (!Array.isArray(chunks)) {
              continue;
            }
            for (const chunkName of chunks) {
              if (!chunkName) {
                continue;
              }
              newInitialChunks.add(String(chunkName));
            }
          }
        }
        const initialChunks = this.initialChunks[compilationId];
        const shouldReload = Boolean(stats.entrypoints) && Boolean(initialChunks) && !isEqualSet(initialChunks, newInitialChunks);
        this.initialChunks[compilationId] = newInitialChunks;
        if (shouldReload) {
          return this.sockWrite({
            type: "content-changed",
            compilationId
          });
        }
        const shouldEmit = !force && stats && !stats.errorsCount && stats.assets && stats.assets.every((asset) => !asset.emitted);
        if (shouldEmit) {
          return this.sockWrite({
            type: "still-ok",
            compilationId
          });
        }
        this.sockWrite({
          type: "hash",
          compilationId,
          data: stats.hash
        });
        if (stats.errorsCount) {
          return this.sockWrite({
            type: "errors",
            compilationId,
            data: getAllStatsErrors(stats)
          });
        }
        if (stats.warningsCount) {
          return this.sockWrite({
            type: "warnings",
            compilationId,
            data: getAllStatsWarnings(stats)
          });
        }
        return this.sockWrite({
          type: "ok",
          compilationId
        });
      }
      // send message to connecting socket
      send(connection, message) {
        if (connection.readyState !== 1) {
          return;
        }
        connection.send(message);
      }
    };
  }
});

// src/server/compilerDevMiddleware.ts
var compilerDevMiddleware_exports = {};
__export(compilerDevMiddleware_exports, {
  CompilerDevMiddleware: () => CompilerDevMiddleware
});
function getClientPaths(devConfig) {
  const clientPaths = [];
  if (!devConfig.hmr && !devConfig.liveReload) {
    return clientPaths;
  }
  clientPaths.push(require.resolve("@rsbuild/core/client/hmr"));
  if (devConfig.client?.overlay) {
    clientPaths.push(`${require.resolve("@rsbuild/core/client/overlay")}`);
  }
  return clientPaths;
}
var noop, CompilerDevMiddleware;
var init_compilerDevMiddleware = __esm({
  "src/server/compilerDevMiddleware.ts"() {
    "use strict";
    init_path();
    init_devMiddleware();
    init_socketServer();
    noop = () => {
    };
    CompilerDevMiddleware = class {
      constructor({ dev, server, compiler, publicPaths }) {
        __publicField(this, "middleware");
        __publicField(this, "devConfig");
        __publicField(this, "serverConfig");
        __publicField(this, "compiler");
        __publicField(this, "publicPaths");
        __publicField(this, "socketServer");
        this.devConfig = dev;
        this.serverConfig = server;
        this.compiler = compiler;
        this.publicPaths = publicPaths;
        this.socketServer = new SocketServer(dev);
      }
      async init() {
        const devMiddleware = await getDevMiddleware(this.compiler);
        this.middleware = this.setupDevMiddleware(devMiddleware, this.publicPaths);
        await this.socketServer.prepare();
      }
      upgrade(req, sock, head) {
        this.socketServer.upgrade(req, sock, head);
      }
      close() {
        this.socketServer.close();
        this.middleware?.close(noop);
      }
      sockWrite(type, data) {
        this.socketServer.sockWrite({
          type,
          data
        });
      }
      setupDevMiddleware(devMiddleware, publicPaths) {
        const { devConfig, serverConfig } = this;
        const callbacks = {
          onInvalid: (compilationId) => {
            this.socketServer.sockWrite({
              type: "invalid",
              compilationId
            });
          },
          onDone: (stats) => {
            this.socketServer.updateStats(stats);
          }
        };
        const clientPaths = getClientPaths(devConfig);
        const middleware = devMiddleware({
          headers: serverConfig.headers,
          publicPath: "/",
          stats: false,
          callbacks,
          clientPaths,
          clientConfig: devConfig.client,
          liveReload: devConfig.liveReload,
          writeToDisk: devConfig.writeToDisk,
          serverSideRender: true,
          // weak is enough in dev
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests#weak_validation
          etag: "weak"
        });
        const assetPrefixes = publicPaths.map(pathnameParse);
        const warp = async (req, res, next) => {
          const { url: url2 } = req;
          const assetPrefix = url2 && assetPrefixes.find((prefix) => url2.startsWith(prefix));
          if (assetPrefix && assetPrefix !== "/") {
            req.url = url2.slice(assetPrefix.length - 1);
            middleware(req, res, (...args) => {
              req.url = url2;
              next(...args);
            });
          } else {
            middleware(req, res, next);
          }
        };
        warp.close = middleware.close;
        return warp;
      }
    };
  }
});

// src/server/devServer.ts
var devServer_exports = {};
__export(devServer_exports, {
  createDevServer: () => createDevServer
});
async function createDevServer(options, createCompiler2, config, {
  compiler: customCompiler,
  getPortSilently,
  runCompile = true
} = {}) {
  import_rslog.logger.debug("create dev server");
  const { port, host, https } = await getServerConfig({
    config,
    getPortSilently
  });
  const devConfig = formatDevConfig(config.dev, port);
  const routes = getRoutes(options.context);
  options.context.devServer = {
    hostname: host,
    port,
    https
  };
  let outputFileSystem = import_node_fs4.default;
  let lastStats;
  const waitFirstCompileDone = runCompile ? new Promise((resolve2) => {
    options.context.hooks.onDevCompileDone.tap(
      ({ stats, isFirstCompile }) => {
        lastStats = "stats" in stats ? stats.stats : [stats];
        if (!isFirstCompile) {
          return;
        }
        resolve2();
      }
    );
  }) : Promise.resolve();
  const startCompile = async () => {
    const compiler = customCompiler || await createCompiler2();
    if (!compiler) {
      throw new Error("Failed to get compiler instance.");
    }
    const { CompilerDevMiddleware: CompilerDevMiddleware2 } = await Promise.resolve().then(() => (init_compilerDevMiddleware(), compilerDevMiddleware_exports));
    const publicPaths = isMultiCompiler(compiler) ? compiler.compilers.map(getPublicPathFromCompiler) : [getPublicPathFromCompiler(compiler)];
    const compilerDevMiddleware = new CompilerDevMiddleware2({
      dev: devConfig,
      server: config.server,
      publicPaths,
      compiler
    });
    await compilerDevMiddleware.init();
    outputFileSystem = (isMultiCompiler(compiler) ? compiler.compilers[0].outputFileSystem : compiler.outputFileSystem) || import_node_fs4.default;
    return {
      middleware: compilerDevMiddleware.middleware,
      sockWrite: (...args) => compilerDevMiddleware.sockWrite(...args),
      onUpgrade: (...args) => compilerDevMiddleware.upgrade(...args),
      close: () => compilerDevMiddleware?.close()
    };
  };
  const protocol = https ? "https" : "http";
  const urls = getAddressUrls({ protocol, port, host });
  await options.context.hooks.onBeforeStartDevServer.call({
    environments: options.context.environments
  });
  const printUrls = () => {
    printServerURLs({
      urls,
      port,
      routes,
      protocol,
      printUrls: config.server.printUrls
    });
  };
  if (runCompile) {
    options.context.hooks.onBeforeCreateCompiler.tap(printUrls);
  } else {
    printUrls();
  }
  const compileMiddlewareAPI = runCompile ? await startCompile() : void 0;
  const fileWatcher = await setupWatchFiles({
    dev: devConfig,
    server: config.server,
    compileMiddlewareAPI
  });
  const pwd = options.context.rootPath;
  const readFileSync = (fileName) => {
    if ("readFileSync" in outputFileSystem) {
      return outputFileSystem.readFileSync(fileName, "utf-8");
    }
    return import_node_fs4.default.readFileSync(fileName, "utf-8");
  };
  const environmentAPI = Object.fromEntries(
    Object.entries(options.context.environments).map(([name, environment]) => {
      return [
        name,
        {
          getStats: async () => {
            if (!runCompile) {
              throw new Error("can't get stats info when runCompile is false");
            }
            await waitFirstCompileDone;
            return lastStats[environment.index];
          },
          loadBundle: async (entryName) => {
            await waitFirstCompileDone;
            return loadBundle(lastStats[environment.index], entryName, {
              readFileSync,
              environment
            });
          },
          getTransformedHtml: async (entryName) => {
            await waitFirstCompileDone;
            return getTransformedHtml(entryName, {
              readFileSync,
              environment
            });
          }
        }
      ];
    })
  );
  const devMiddlewares = await getMiddlewares({
    pwd,
    compileMiddlewareAPI,
    dev: devConfig,
    server: config.server,
    environments: environmentAPI,
    output: {
      distPath: options.context.distPath || ROOT_DIST_DIR
    },
    outputFileSystem
  });
  const { default: connect } = await import("../compiled/connect/index.js");
  const middlewares = connect();
  for (const item of devMiddlewares.middlewares) {
    if (Array.isArray(item)) {
      middlewares.use(...item);
    } else {
      middlewares.use(item);
    }
  }
  const devServerAPI = {
    port,
    middlewares,
    environments: environmentAPI,
    listen: async () => {
      const httpServer = await createHttpServer({
        serverConfig: config.server,
        middlewares
      });
      const serverTerminator = getServerTerminator(httpServer);
      import_rslog.logger.debug("listen dev server");
      options.context.hooks.onCloseDevServer.tap(serverTerminator);
      return new Promise((resolve2) => {
        httpServer.listen(
          {
            host,
            port
          },
          async (err) => {
            if (err) {
              throw err;
            }
            middlewares.use(notFoundMiddleware);
            httpServer.on("upgrade", devMiddlewares.onUpgrade);
            import_rslog.logger.debug("listen dev server done");
            await devServerAPI.afterListen();
            onBeforeRestartServer(devServerAPI.close);
            resolve2({
              port,
              urls: urls.map((item) => item.url),
              server: {
                close: devServerAPI.close
              }
            });
          }
        );
      });
    },
    afterListen: async () => {
      await options.context.hooks.onAfterStartDevServer.call({
        port,
        routes,
        environments: options.context.environments
      });
    },
    connectWebSocket: ({ server }) => {
      server.on("upgrade", devMiddlewares.onUpgrade);
    },
    close: async () => {
      await options.context.hooks.onCloseDevServer.call();
      await Promise.all([devMiddlewares.close(), fileWatcher?.close()]);
    },
    printUrls
  };
  import_rslog.logger.debug("create dev server done");
  return devServerAPI;
}
var import_node_fs4, formatDevConfig;
var init_devServer = __esm({
  "src/server/devServer.ts"() {
    "use strict";
    import_node_fs4 = __toESM(require("fs"));
    init_constants();
    init_helpers();
    init_logger();
    init_environment();
    init_getDevMiddlewares();
    init_helper();
    init_httpServer();
    init_middlewares();
    init_restart();
    init_watchFiles();
    formatDevConfig = (config, port) => {
      if (config.client.port === "<port>") {
        config.client.port = String(port);
      }
      return config;
    };
  }
});

// src/provider/build.ts
var build_exports = {};
__export(build_exports, {
  build: () => build
});
var import_core4, build;
var init_build = __esm({
  "src/provider/build.ts"() {
    "use strict";
    import_core4 = require("@rspack/core");
    init_hooks();
    init_logger();
    init_createCompiler();
    build = async (initOptions, { watch, compiler: customCompiler } = {}) => {
      const { context } = initOptions;
      let compiler;
      let bundlerConfigs;
      if (customCompiler) {
        compiler = customCompiler;
      } else {
        const result = await createCompiler(initOptions);
        compiler = result.compiler;
        bundlerConfigs = result.rspackConfigs;
      }
      registerBuildHook({
        context,
        bundlerConfigs,
        compiler,
        isWatch: Boolean(watch),
        MultiStatsCtor: import_core4.rspack.MultiStats
      });
      if (watch) {
        const watching = compiler.watch({}, (err) => {
          if (err) {
            import_rslog.logger.error(err);
          }
        });
        return {
          close: () => new Promise((resolve2) => {
            watching.close(() => {
              resolve2();
            });
          })
        };
      }
      const { stats } = await new Promise((resolve2, reject) => {
        compiler.run((err, stats2) => {
          if (err) {
            reject(err);
          } else if (stats2?.hasErrors()) {
            reject(new Error("Rspack build failed!"));
          } else {
            compiler.close((closeErr) => {
              if (closeErr) {
                import_rslog.logger.error(closeErr);
              }
              resolve2({ stats: stats2 });
            });
          }
        });
      });
      return {
        stats,
        // This close method is a noop in non-watch mode
        // In watch mode, it's defined above to stop watching
        close: async () => {
        }
      };
    };
  }
});

// src/provider/provider.ts
var provider_exports = {};
__export(provider_exports, {
  rspackProvider: () => rspackProvider
});
var rspackProvider;
var init_provider = __esm({
  "src/provider/provider.ts"() {
    "use strict";
    init_initConfigs();
    rspackProvider = async ({
      context,
      pluginManager,
      rsbuildOptions
    }) => {
      const createCompiler2 = async () => {
        const { createCompiler: createCompiler3 } = await Promise.resolve().then(() => (init_createCompiler(), createCompiler_exports));
        const result = await createCompiler3({
          context,
          pluginManager,
          rsbuildOptions
        });
        return result.compiler;
      };
      return {
        bundler: "rspack",
        createCompiler: createCompiler2,
        async createDevServer(options) {
          const { createDevServer: createDevServer2 } = await Promise.resolve().then(() => (init_devServer(), devServer_exports));
          const config = await initRsbuildConfig({ context, pluginManager });
          return createDevServer2(
            { context, pluginManager, rsbuildOptions },
            createCompiler2,
            config,
            options
          );
        },
        async startDevServer(options) {
          const { createDevServer: createDevServer2 } = await Promise.resolve().then(() => (init_devServer(), devServer_exports));
          const config = await initRsbuildConfig({ context, pluginManager });
          const server = await createDevServer2(
            { context, pluginManager, rsbuildOptions },
            createCompiler2,
            config,
            options
          );
          return server.listen();
        },
        async build(options) {
          const { build: build2 } = await Promise.resolve().then(() => (init_build(), build_exports));
          return build2({ context, pluginManager, rsbuildOptions }, options);
        },
        async initConfigs() {
          const { rspackConfigs } = await initConfigs({
            context,
            pluginManager,
            rsbuildOptions
          });
          return rspackConfigs;
        },
        async inspectConfig(inspectOptions) {
          const { inspectConfig: inspectConfig2 } = await Promise.resolve().then(() => (init_inspectConfig(), inspectConfig_exports));
          return inspectConfig2({
            context,
            pluginManager,
            rsbuildOptions,
            inspectOptions
          });
        }
      };
    };
  }
});

// src/plugins/basic.ts
var basic_exports = {};
__export(basic_exports, {
  pluginBasic: () => pluginBasic
});
var import_node_path18, getJsSourceMap, pluginBasic;
var init_basic2 = __esm({
  "src/plugins/basic.ts"() {
    "use strict";
    import_node_path18 = __toESM(require("path"));
    getJsSourceMap = (config) => {
      const { sourceMap } = config.output;
      if (sourceMap.js === void 0) {
        return config.mode === "production" ? false : "cheap-module-source-map";
      }
      return sourceMap.js;
    };
    pluginBasic = () => ({
      name: "rsbuild:basic",
      setup(api) {
        api.modifyBundlerChain(
          (chain, { env, isDev, target, bundler, environment, CHAIN_ID: CHAIN_ID2 }) => {
            const { config } = environment;
            chain.name(environment.name);
            chain.devtool(getJsSourceMap(config));
            chain.context(api.context.rootPath);
            chain.mode(environment.config.mode);
            chain.merge({
              infrastructureLogging: {
                // Using `error` level to avoid `cache.PackFileCacheStrategy` logs
                level: "error"
              }
            });
            chain.performance.hints(false);
            chain.module.parser.merge({
              javascript: {
                exportsPresence: "error"
              }
            });
            const usingHMR = isDev && config.dev.hmr && target === "web";
            if (usingHMR) {
              chain.plugin(CHAIN_ID2.PLUGIN.HMR).use(bundler.HotModuleReplacementPlugin);
            }
            if (env === "development") {
              chain.output.devtoolModuleFilenameTemplate(
                (info) => import_node_path18.default.resolve(info.absoluteResourcePath).replace(/\\/g, "/")
              );
            }
            process.env.RSPACK_CONFIG_VALIDATE ||= "loose-unrecognized-keys";
            process.env.WATCHPACK_WATCHER_LIMIT ||= "20";
          }
        );
      }
    });
  }
});

// src/plugins/entry.ts
var entry_exports = {};
__export(entry_exports, {
  pluginEntry: () => pluginEntry
});
var import_picocolors11, pluginEntry;
var init_entry = __esm({
  "src/plugins/entry.ts"() {
    "use strict";
    import_picocolors11 = __toESM(require("../compiled/picocolors/index.js"));
    init_helpers();
    pluginEntry = () => ({
      name: "rsbuild:entry",
      setup(api) {
        api.modifyBundlerChain(async (chain, { environment, isServer }) => {
          const { config, entry } = environment;
          const { preEntry } = config.source;
          const injectCoreJsEntry = config.output.polyfill === "entry" && !isServer;
          for (const entryName of Object.keys(entry)) {
            const entryPoint = chain.entry(entryName);
            const addEntry = (item) => {
              if (typeof item === "object" && "html" in item) {
                const { html, ...rest } = item;
                entryPoint.add(rest);
              } else {
                entryPoint.add(item);
              }
            };
            preEntry.forEach(addEntry);
            if (injectCoreJsEntry) {
              addEntry(createVirtualModule('import "core-js";'));
            }
            castArray(entry[entryName]).forEach(addEntry);
          }
        });
        api.onBeforeCreateCompiler(({ bundlerConfigs }) => {
          if (bundlerConfigs.every((config) => !config.entry)) {
            throw new Error(
              `Could not find any entry module, please make sure that ${import_picocolors11.default.cyan(
                "src/index.(ts|js|tsx|jsx|mjs|cjs)"
              )} exists, or customize entry through the ${import_picocolors11.default.cyan(
                "source.entry"
              )} configuration.`
            );
          }
        });
      }
    });
  }
});

// src/plugins/cache.ts
var cache_exports = {};
__export(cache_exports, {
  pluginCache: () => pluginCache
});
async function validateCache(cacheDirectory, buildDependencies) {
  const configFile = (0, import_node_path19.join)(cacheDirectory, "buildDependencies.json");
  if (await isFileExists(configFile)) {
    const rawConfigFile = await import_node_fs5.default.promises.readFile(configFile, "utf-8");
    const prevBuildDependencies = JSON.parse(rawConfigFile);
    if (JSON.stringify(prevBuildDependencies) === JSON.stringify(buildDependencies)) {
      return;
    }
    await import_node_fs5.default.promises.rm(cacheDirectory, { force: true, recursive: true });
  }
  await import_node_fs5.default.promises.mkdir(cacheDirectory, { recursive: true });
  await import_node_fs5.default.promises.writeFile(configFile, JSON.stringify(buildDependencies));
}
function getDigestHash(digest) {
  const fsHash = import_node_crypto.default.createHash("md5");
  const md5 = fsHash.update(JSON.stringify(digest)).digest("hex").slice(0, 8);
  return md5;
}
function getCacheDirectory({ cacheDirectory }, context) {
  if (cacheDirectory) {
    return (0, import_node_path19.isAbsolute)(cacheDirectory) ? cacheDirectory : (0, import_node_path19.join)(context.rootPath, cacheDirectory);
  }
  return (0, import_node_path19.join)(context.cachePath, context.bundlerType);
}
async function getBuildDependencies(context, config, environmentContext) {
  const rootPackageJson = (0, import_node_path19.join)(context.rootPath, "package.json");
  const browserslistConfig = (0, import_node_path19.join)(context.rootPath, ".browserslistrc");
  const buildDependencies = {};
  if (await isFileExists(rootPackageJson)) {
    buildDependencies.packageJson = [rootPackageJson];
  }
  const { tsconfigPath } = environmentContext;
  if (tsconfigPath) {
    buildDependencies.tsconfig = [tsconfigPath];
  }
  if (config._privateMeta?.configFilePath) {
    buildDependencies.rsbuildConfig = [config._privateMeta.configFilePath];
  }
  if (await isFileExists(browserslistConfig)) {
    buildDependencies.browserslistrc = [browserslistConfig];
  }
  const tailwindExts = ["ts", "js", "cjs", "mjs"];
  const configs = tailwindExts.map(
    (ext) => (0, import_node_path19.join)(context.rootPath, `tailwind.config.${ext}`)
  );
  const tailwindConfig = findExists(configs);
  if (tailwindConfig) {
    buildDependencies.tailwindcss = [tailwindConfig];
  }
  return buildDependencies;
}
var import_node_crypto, import_node_fs5, import_node_path19, pluginCache;
var init_cache = __esm({
  "src/plugins/cache.ts"() {
    "use strict";
    import_node_crypto = __toESM(require("crypto"));
    import_node_fs5 = __toESM(require("fs"));
    import_node_path19 = require("path");
    init_helpers();
    pluginCache = () => ({
      name: "rsbuild:cache",
      setup(api) {
        if (api.context.bundlerType === "rspack") {
          return;
        }
        api.modifyBundlerChain(async (chain, { environment, env }) => {
          const { config } = environment;
          const { buildCache } = config.performance;
          if (buildCache === false) {
            chain.cache(false);
            return;
          }
          const { context } = api;
          const cacheConfig = typeof buildCache === "boolean" ? {} : buildCache;
          const cacheDirectory = getCacheDirectory(cacheConfig, context);
          const buildDependencies = await getBuildDependencies(
            context,
            config,
            environment
          );
          await validateCache(cacheDirectory, buildDependencies);
          const useDigest = Array.isArray(cacheConfig.cacheDigest) && cacheConfig.cacheDigest.length;
          chain.cache({
            // The default cache name of webpack is '${name}-${env}', and the `name` is `default` by default.
            // We set cache name to avoid cache conflicts of different targets.
            name: useDigest ? `${environment.name}-${env}-${getDigestHash(cacheConfig.cacheDigest)}` : `${environment.name}-${env}`,
            type: "filesystem",
            cacheDirectory,
            buildDependencies
          });
        });
      }
    });
  }
});

// ../../node_modules/.pnpm/browserslist-to-es-version@1.0.0/node_modules/browserslist-to-es-version/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  browserslistToESVersion: () => browserslistToESVersion
});
function browserslistToESVersion(browsers) {
  const projectBrowsers = (0, import_browserslist2.default)(browsers, {
    ignoreUnknownVersions: true
  });
  let esVersion = 2018;
  for (const item of projectBrowsers) {
    const pairs = item.split(" ");
    if (pairs.length < 2) {
      continue;
    }
    const browser = renameBrowser(pairs[0]);
    const version2 = Number(pairs[1].split("-")[0]);
    if (Number.isNaN(version2)) {
      continue;
    }
    if (browser === "ie" || browser === "android" && version2 < 6) {
      esVersion = 5;
      break;
    }
    const versions = ES_VERSIONS_MAP[browser];
    if (!versions) {
      continue;
    }
    if (version2 < versions[0]) {
      esVersion = Math.min(5, esVersion);
    } else if (version2 < versions[1]) {
      esVersion = Math.min(2015, esVersion);
    } else if (version2 < versions[2]) {
      esVersion = Math.min(2016, esVersion);
    } else if (version2 < versions[3]) {
      esVersion = Math.min(2017, esVersion);
    }
  }
  return esVersion;
}
var import_browserslist2, ES_VERSIONS_MAP, renameBrowser;
var init_dist2 = __esm({
  "../../node_modules/.pnpm/browserslist-to-es-version@1.0.0/node_modules/browserslist-to-es-version/dist/index.js"() {
    "use strict";
    import_browserslist2 = __toESM(require("../compiled/browserslist/index.js"));
    ES_VERSIONS_MAP = {
      chrome: [51, 52, 57, 64],
      edge: [15, 15, 15, 79],
      safari: [10, 10.3, 11, 16.4],
      firefox: [54, 54, 54, 78],
      opera: [38, 39, 44, 51],
      samsung: [5, 6.2, 6.2, 8.2]
    };
    renameBrowser = (name) => {
      return name === "ios_saf" ? "safari" : name;
    };
  }
});

// src/plugins/target.ts
var target_exports = {};
__export(target_exports, {
  pluginTarget: () => pluginTarget
});
var getESVersion, pluginTarget;
var init_target = __esm({
  "src/plugins/target.ts"() {
    "use strict";
    init_constants();
    getESVersion = async (browserslist3) => {
      const { browserslistToESVersion: browserslistToESVersion2 } = await Promise.resolve().then(() => (init_dist2(), dist_exports));
      if (browserslist3.join(",") === DEFAULT_WEB_BROWSERSLIST.join(",")) {
        return 2017;
      }
      return browserslistToESVersion2(browserslist3);
    };
    pluginTarget = () => ({
      name: "rsbuild:target",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, { target, environment }) => {
            if (target === "node") {
              chain.target("node");
              return;
            }
            const { browserslist: browserslist3 } = environment;
            const esVersion = await getESVersion(browserslist3);
            if (target === "web-worker") {
              chain.target(["webworker", `es${esVersion}`]);
              return;
            }
            chain.target(["web", `es${esVersion}`]);
          }
        });
      }
    });
  }
});

// src/plugins/css.ts
var css_exports = {};
__export(css_exports, {
  isUseCssExtract: () => isUseCssExtract,
  normalizeCssLoaderOptions: () => normalizeCssLoaderOptions,
  pluginCss: () => pluginCss
});
async function loadUserPostcssrc(root) {
  const cached = userPostcssrcCache.get(root);
  if (cached) {
    return clonePostCSSConfig(await cached);
  }
  const { default: postcssrc } = await import("../compiled/postcss-load-config/index.js");
  const promise = postcssrc({}, root).catch((err) => {
    if (err.message?.includes("No PostCSS Config found")) {
      return {};
    }
    throw err;
  });
  userPostcssrcCache.set(root, promise);
  return promise.then((config) => {
    userPostcssrcCache.set(root, config);
    return clonePostCSSConfig(config);
  });
}
async function applyCSSRule({
  rule,
  config,
  context,
  utils: { target, isProd, CHAIN_ID: CHAIN_ID2, environment }
}) {
  const enableExtractCSS = isUseCssExtract(config, target);
  if (target === "web") {
    if (enableExtractCSS) {
      rule.use(CHAIN_ID2.USE.MINI_CSS_EXTRACT).loader(getCssExtractPlugin().loader).options(config.tools.cssExtract.loaderOptions);
    } else {
      const styleLoaderOptions = reduceConfigs({
        initial: {},
        config: config.tools.styleLoader
      });
      rule.use(CHAIN_ID2.USE.STYLE).loader(getCompiledPath("style-loader")).options(styleLoaderOptions);
    }
  } else {
    rule.use(CHAIN_ID2.USE.IGNORE_CSS).loader(import_node_path20.default.join(LOADER_PATH, "ignoreCssLoader.cjs"));
  }
  let importLoaders = 0;
  rule.use(CHAIN_ID2.USE.CSS).loader(getCompiledPath("css-loader"));
  if (target === "web") {
    if (context.bundlerType === "rspack" && config.tools.lightningcssLoader !== false) {
      importLoaders++;
      const userOptions = config.tools.lightningcssLoader === true ? {} : config.tools.lightningcssLoader;
      const initialOptions = {
        targets: environment.browserslist
      };
      if (config.mode === "production" && config.output.injectStyles) {
        initialOptions.minify = true;
      }
      const loaderOptions = reduceConfigs({
        initial: initialOptions,
        config: userOptions
      });
      rule.use(CHAIN_ID2.USE.LIGHTNINGCSS).loader("builtin:lightningcss-loader").options(loaderOptions);
    }
    const postcssLoaderOptions = await getPostcssLoaderOptions({
      config,
      root: context.rootPath
    });
    if (postcssLoaderOptions.postcssOptions?.plugins?.length) {
      importLoaders++;
      rule.use(CHAIN_ID2.USE.POSTCSS).loader(getCompiledPath("postcss-loader")).options(postcssLoaderOptions);
    }
  }
  const localIdentName = getCSSModulesLocalIdentName(config, isProd);
  const cssLoaderOptions = getCSSLoaderOptions({
    config,
    importLoaders,
    target,
    localIdentName
  });
  rule.use(CHAIN_ID2.USE.CSS).options(cssLoaderOptions);
  rule.merge({ sideEffects: true });
  rule.resolve.preferRelative(true);
}
var import_node_path20, import_deepmerge2, isUseCssExtract, getCSSModulesLocalIdentName, normalizeCssLoaderOptions, userPostcssrcCache, clonePostCSSConfig, getPostcssLoaderOptions, getCSSLoaderOptions, pluginCss;
var init_css = __esm({
  "src/plugins/css.ts"() {
    "use strict";
    import_node_path20 = __toESM(require("path"));
    import_deepmerge2 = __toESM(require_cjs());
    init_dist();
    init_constants();
    init_path();
    init_pluginHelper();
    isUseCssExtract = (config, target) => !config.output.injectStyles && target !== "node" && target !== "web-worker";
    getCSSModulesLocalIdentName = (config, isProd) => config.output.cssModules.localIdentName || // Using shorter classname in production to reduce bundle size
    (isProd ? "[local]-[hash:base64:6]" : "[path][name]__[local]-[hash:base64:6]");
    normalizeCssLoaderOptions = (options, exportOnlyLocals) => {
      if (options.modules && exportOnlyLocals) {
        let { modules } = options;
        if (modules === true) {
          modules = { exportOnlyLocals: true };
        } else if (typeof modules === "string") {
          modules = {
            mode: modules,
            exportOnlyLocals: true
          };
        } else {
          modules = {
            ...modules,
            exportOnlyLocals: true
          };
        }
        return {
          ...options,
          modules
        };
      }
      return options;
    };
    userPostcssrcCache = /* @__PURE__ */ new Map();
    clonePostCSSConfig = (config) => ({
      ...config,
      plugins: config.plugins ? [...config.plugins] : void 0
    });
    getPostcssLoaderOptions = async ({
      config,
      root
    }) => {
      const extraPlugins = [];
      const utils = {
        addPlugins(plugins) {
          if (Array.isArray(plugins)) {
            extraPlugins.push(...plugins);
          } else {
            extraPlugins.push(plugins);
          }
        }
      };
      const userPostcssConfig = await loadUserPostcssrc(root);
      userPostcssConfig.plugins ||= [];
      const defaultPostcssConfig = {
        implementation: getCompiledPath("postcss"),
        postcssOptions: userPostcssConfig,
        sourceMap: config.output.sourceMap.css
      };
      const mergedConfig = reduceConfigsWithContext({
        initial: defaultPostcssConfig,
        config: config.tools.postcss,
        ctx: utils
      });
      if (extraPlugins.length) {
        mergedConfig?.postcssOptions?.plugins.push(...extraPlugins);
      }
      mergedConfig.postcssOptions ||= {};
      mergedConfig.postcssOptions.config = false;
      return mergedConfig;
    };
    getCSSLoaderOptions = ({
      config,
      importLoaders,
      target,
      localIdentName
    }) => {
      const { cssModules } = config.output;
      const defaultOptions2 = {
        importLoaders,
        modules: {
          ...cssModules,
          localIdentName
        },
        sourceMap: config.output.sourceMap.css,
        _skipReuseAST: config.tools.lightningcssLoader !== false
      };
      const mergedCssLoaderOptions = reduceConfigs({
        initial: defaultOptions2,
        config: config.tools.cssLoader,
        mergeFn: import_deepmerge2.default
      });
      const cssLoaderOptions = normalizeCssLoaderOptions(
        mergedCssLoaderOptions,
        target !== "web"
      );
      return cssLoaderOptions;
    };
    pluginCss = () => ({
      name: "rsbuild:css",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, utils) => {
            const rule = chain.module.rule(utils.CHAIN_ID.RULE.CSS);
            const { config } = utils.environment;
            rule.test(CSS_REGEX).type("javascript/auto");
            await applyCSSRule({
              rule,
              utils,
              config,
              context: api.context
            });
          }
        });
      }
    });
  }
});

// src/plugins/open.ts
var open_exports = {};
__export(open_exports, {
  openBrowser: () => openBrowser,
  pluginOpen: () => pluginOpen,
  replacePortPlaceholder: () => replacePortPlaceholder,
  resolveUrl: () => resolveUrl
});
async function openBrowser(url2) {
  const shouldTryOpenChromeWithAppleScript = process.platform === "darwin";
  if (shouldTryOpenChromeWithAppleScript) {
    try {
      const targetBrowser = await getTargetBrowser();
      if (targetBrowser) {
        await execAsync(
          `osascript openChrome.applescript "${encodeURI(
            url2
          )}" "${targetBrowser}"`,
          {
            cwd: STATIC_PATH
          }
        );
        return true;
      }
      import_rslog.logger.debug("Failed to find the target browser.");
    } catch (err) {
      import_rslog.logger.debug("Failed to open start URL with apple script.");
      import_rslog.logger.debug(err);
    }
  }
  try {
    const { default: open } = await import("../compiled/open/index.js");
    await open(url2);
    return true;
  } catch (err) {
    import_rslog.logger.error("Failed to open start URL.");
    import_rslog.logger.error(err);
    return false;
  }
}
function resolveUrl(str, base) {
  if (canParse(str)) {
    return str;
  }
  try {
    const url2 = new URL(str, base);
    return url2.href;
  } catch (e) {
    throw new Error(
      "[rsbuild:open]: Invalid input: not a valid URL or pathname"
    );
  }
}
function pluginOpen() {
  return {
    name: "rsbuild:open",
    setup(api) {
      const onStartServer = async (params) => {
        const { port, routes } = params;
        const config = api.getNormalizedConfig();
        const { https } = api.context.devServer || {};
        const { targets, before } = normalizeOpenConfig(config);
        const isCodesandbox = process.env.CSB === "true";
        const shouldOpen = targets !== void 0 && !isCodesandbox;
        if (!shouldOpen) {
          return;
        }
        const urls = [];
        const protocol = https ? "https" : "http";
        const baseUrl = `${protocol}://localhost:${port}`;
        if (!targets.length) {
          if (routes.length) {
            urls.push(`${baseUrl}${routes[0].pathname}`);
          }
        } else {
          urls.push(
            ...targets.map(
              (target) => resolveUrl(replacePortPlaceholder(target, port), baseUrl)
            )
          );
        }
        const openUrls = () => {
          for (const url2 of urls) {
            if (!openedURLs.includes(url2)) {
              openBrowser(url2);
              openedURLs.push(url2);
            }
          }
        };
        if (before) {
          await before();
        }
        openUrls();
      };
      api.onAfterStartDevServer(onStartServer);
      api.onAfterStartProdServer(onStartServer);
    }
  };
}
var import_node_child_process, import_node_util, execAsync, supportedChromiumBrowsers, getTargetBrowser, replacePortPlaceholder, openedURLs, normalizeOpenConfig;
var init_open = __esm({
  "src/plugins/open.ts"() {
    "use strict";
    import_node_child_process = require("child_process");
    import_node_util = require("util");
    init_constants();
    init_helpers();
    init_logger();
    execAsync = (0, import_node_util.promisify)(import_node_child_process.exec);
    supportedChromiumBrowsers = [
      "Google Chrome Canary",
      "Google Chrome Dev",
      "Google Chrome Beta",
      "Google Chrome",
      "Microsoft Edge",
      "Brave Browser",
      "Vivaldi",
      "Chromium"
    ];
    getTargetBrowser = async () => {
      let targetBrowser = process.env.BROWSER;
      if (!targetBrowser || !supportedChromiumBrowsers.includes(targetBrowser)) {
        const { stdout: ps } = await execAsync("ps cax");
        targetBrowser = supportedChromiumBrowsers.find((b) => ps.includes(b));
      }
      return targetBrowser;
    };
    replacePortPlaceholder = (url2, port) => url2.replace(/<port>/g, String(port));
    openedURLs = [];
    normalizeOpenConfig = (config) => {
      const { open } = config.server;
      if (open === false) {
        return {};
      }
      if (open === true) {
        return { targets: [] };
      }
      if (typeof open === "string") {
        return { targets: [open] };
      }
      if (Array.isArray(open)) {
        return { targets: open };
      }
      return {
        targets: open.target ? castArray(open.target) : [],
        before: open.before
      };
    };
  }
});

// src/plugins/output.ts
var output_exports = {};
__export(output_exports, {
  pluginOutput: () => pluginOutput
});
function getPublicPath({
  isProd,
  config,
  context
}) {
  const { dev, output } = config;
  let publicPath = DEFAULT_ASSET_PREFIX;
  const port = context.devServer?.port || DEFAULT_PORT;
  if (isProd) {
    if (typeof output.assetPrefix === "string") {
      publicPath = output.assetPrefix;
    }
  } else if (typeof dev.assetPrefix === "string") {
    publicPath = dev.assetPrefix;
  } else if (dev.assetPrefix === true) {
    const protocol = context.devServer?.https ? "https" : "http";
    const hostname = context.devServer?.hostname || DEFAULT_DEV_HOST;
    if (hostname === DEFAULT_DEV_HOST) {
      const localHostname = "localhost";
      publicPath = `${protocol}://${localHostname}:<port>/`;
    } else {
      publicPath = `${protocol}://${hostname}:<port>/`;
    }
  }
  return formatPublicPath(replacePortPlaceholder(publicPath, port));
}
var import_node_path21, import_core5, getJsAsyncPath, pluginOutput;
var init_output = __esm({
  "src/plugins/output.ts"() {
    "use strict";
    import_node_path21 = require("path");
    import_core5 = require("@rspack/core");
    init_constants();
    init_helpers();
    init_pluginHelper();
    init_css();
    init_open();
    getJsAsyncPath = (jsPath, isServer, jsAsync) => {
      if (jsAsync !== void 0) {
        return jsAsync;
      }
      if (isServer) {
        return jsPath;
      }
      return jsPath ? `${jsPath}/async` : "async";
    };
    pluginOutput = () => ({
      name: "rsbuild:output",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { CHAIN_ID: CHAIN_ID2, target, isProd, isServer, environment }) => {
            const { distPath, config } = environment;
            const publicPath = getPublicPath({
              config,
              isProd,
              context: api.context
            });
            const jsPath = config.output.distPath.js;
            const jsAsyncPath = getJsAsyncPath(
              jsPath,
              isServer,
              config.output.distPath.jsAsync
            );
            const jsFilename = getFilename(config, "js", isProd, isServer);
            const isJsFilenameFn = typeof jsFilename === "function";
            chain.output.path(distPath).filename(
              isJsFilenameFn ? (...args) => {
                const name = jsFilename(...args);
                return import_node_path21.posix.join(jsPath, name);
              } : import_node_path21.posix.join(jsPath, jsFilename)
            ).chunkFilename(
              isJsFilenameFn ? (...args) => {
                const name = jsFilename(...args);
                return import_node_path21.posix.join(jsAsyncPath, name);
              } : import_node_path21.posix.join(jsAsyncPath, jsFilename)
            ).publicPath(publicPath).pathinfo(false).hashFunction("xxhash64");
            if (isServer) {
              chain.output.library({
                type: "commonjs2",
                ...chain.output.get("library") || {}
              });
            }
            if (config.output.copy && api.context.bundlerType === "rspack") {
              const { copy } = config.output;
              const options = Array.isArray(copy) ? { patterns: copy } : copy;
              chain.plugin(CHAIN_ID2.PLUGIN.COPY).use(import_core5.rspack.CopyRspackPlugin, [options]);
            }
            if (isUseCssExtract(config, target)) {
              const extractPluginOptions = config.tools.cssExtract.pluginOptions;
              const cssPath = config.output.distPath.css;
              const cssFilename = getFilename(config, "css", isProd);
              const cssAsyncPath = config.output.distPath.cssAsync ?? (cssPath ? `${cssPath}/async` : "async");
              chain.plugin(CHAIN_ID2.PLUGIN.MINI_CSS_EXTRACT).use(getCssExtractPlugin(), [
                {
                  filename: import_node_path21.posix.join(cssPath, cssFilename),
                  chunkFilename: import_node_path21.posix.join(cssAsyncPath, cssFilename),
                  ...extractPluginOptions
                }
              ]);
            }
          }
        );
      }
    });
  }
});

// src/plugins/resolve.ts
var resolve_exports = {};
__export(resolve_exports, {
  pluginResolve: () => pluginResolve
});
function applyFullySpecified({
  chain,
  CHAIN_ID: CHAIN_ID2
}) {
  chain.module.rule(CHAIN_ID2.RULE.MJS).test(/\.m?js/).resolve.set("fullySpecified", false);
}
function applyExtensions({ chain }) {
  const extensions = [
    // most projects are using TypeScript, resolve .ts(x) files first to reduce resolve time.
    ".ts",
    ".tsx",
    ".mjs",
    ".js",
    ".jsx",
    ".json"
  ];
  chain.resolve.extensions.merge(extensions);
}
function applyAlias({
  chain,
  config,
  rootPath
}) {
  const { alias } = config.source;
  if (!alias) {
    return;
  }
  const mergedAlias = reduceConfigs({
    initial: {},
    config: alias
  });
  for (const name of Object.keys(mergedAlias)) {
    const values = castArray(mergedAlias[name]);
    const formattedValues = values.map((value) => {
      if (typeof value === "string" && value.startsWith(".")) {
        return ensureAbsolutePath(rootPath, value);
      }
      return value;
    });
    chain.resolve.alias.set(
      name,
      formattedValues.length === 1 ? formattedValues[0] : formattedValues
    );
  }
}
var pluginResolve;
var init_resolve = __esm({
  "src/plugins/resolve.ts"() {
    "use strict";
    init_dist();
    init_helpers();
    init_path();
    pluginResolve = () => ({
      name: "rsbuild:resolve",
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: (chain, { environment, CHAIN_ID: CHAIN_ID2 }) => {
            const { config, tsconfigPath } = environment;
            applyExtensions({ chain });
            applyAlias({
              chain,
              config,
              rootPath: api.context.rootPath
            });
            applyFullySpecified({ chain, config, CHAIN_ID: CHAIN_ID2 });
            if (tsconfigPath && // Only Rspack has the tsConfig option
            api.context.bundlerType === "rspack" && config.source.aliasStrategy === "prefer-tsconfig") {
              chain.resolve.tsConfig({
                configFile: tsconfigPath
              });
            }
          }
        });
      }
    });
  }
});

// src/plugins/fileSize.ts
var fileSize_exports = {};
__export(fileSize_exports, {
  filterAsset: () => filterAsset,
  pluginFileSize: () => pluginFileSize
});
async function gzipSize(input) {
  const data = await gzip(input);
  return data.length;
}
function getHeader(longestFileLength, longestLabelLength, options) {
  const longestLengths = [longestFileLength, longestLabelLength];
  const rowTypes = ["File", "Size"];
  if (options.compressed) {
    rowTypes.push("Gzipped");
  }
  const headerRow = rowTypes.reduce((prev, cur, index) => {
    const length = longestLengths[index];
    let curLabel = cur;
    if (length) {
      curLabel = cur.length < length ? cur + " ".repeat(length - cur.length) : cur;
    }
    return `${prev + curLabel}    `;
  }, "  ");
  return import_picocolors12.default.bold(import_picocolors12.default.blue(headerRow));
}
async function printFileSizes(options, stats, rootPath) {
  const logs = [];
  if (options.detail === false && options.total === false) {
    return logs;
  }
  const formatAsset = async (asset, distPath, distFolder) => {
    const fileName = asset.name.split("?")[0];
    const contents = await import_node_fs6.default.promises.readFile(import_node_path22.default.join(distPath, fileName));
    const size = contents.length;
    const gzippedSize = options.compressed ? await gzipSize(contents) : null;
    const gzipSizeLabel = gzippedSize ? getAssetColor(gzippedSize)(calcFileSize(gzippedSize)) : null;
    return {
      size,
      folder: import_node_path22.default.join(distFolder, import_node_path22.default.dirname(fileName)),
      name: import_node_path22.default.basename(fileName),
      gzippedSize,
      sizeLabel: calcFileSize(size),
      gzipSizeLabel
    };
  };
  const getAssets = async () => {
    const distPath = stats.compilation.outputOptions.path;
    if (!distPath) {
      return [];
    }
    const origin = stats.toJson({
      all: false,
      assets: true,
      cachedAssets: true,
      groupAssetsByInfo: false,
      groupAssetsByPath: false,
      groupAssetsByChunk: false,
      groupAssetsByExtension: false,
      groupAssetsByEmitStatus: false
    });
    const filteredAssets = origin.assets.filter(
      (asset) => filterAsset(asset.name)
    );
    const distFolder = import_node_path22.default.relative(rootPath, distPath);
    return Promise.all(
      filteredAssets.map((asset) => formatAsset(asset, distPath, distFolder))
    );
  };
  const assets = await getAssets();
  if (assets.length === 0) {
    return logs;
  }
  assets.sort((a, b) => a.size - b.size);
  const longestLabelLength = Math.max(...assets.map((a) => a.sizeLabel.length));
  const longestFileLength = Math.max(
    ...assets.map((a) => (a.folder + import_node_path22.default.sep + a.name).length)
  );
  if (options.detail !== false) {
    logs.push(getHeader(longestFileLength, longestLabelLength, options));
  }
  let totalSize = 0;
  let totalGzipSize = 0;
  for (const asset of assets) {
    let { sizeLabel } = asset;
    const { name, folder, gzipSizeLabel } = asset;
    const fileNameLength = (folder + import_node_path22.default.sep + name).length;
    const sizeLength = sizeLabel.length;
    totalSize += asset.size;
    if (asset.gzippedSize) {
      totalGzipSize += asset.gzippedSize;
    }
    if (options.detail !== false) {
      if (sizeLength < longestLabelLength) {
        const rightPadding = " ".repeat(longestLabelLength - sizeLength);
        sizeLabel += rightPadding;
      }
      let fileNameLabel = import_picocolors12.default.dim(asset.folder + import_node_path22.default.sep) + coloringAssetName(asset.name);
      if (fileNameLength < longestFileLength) {
        const rightPadding = " ".repeat(longestFileLength - fileNameLength);
        fileNameLabel += rightPadding;
      }
      let log = `  ${fileNameLabel}    ${sizeLabel}`;
      if (gzipSizeLabel) {
        log += `    ${gzipSizeLabel}`;
      }
      logs.push(log);
    }
  }
  if (options.total !== false) {
    const totalSizeLabel = `${import_picocolors12.default.bold(
      import_picocolors12.default.blue("Total size:")
    )}  ${calcFileSize(totalSize)}`;
    let log = `
  ${totalSizeLabel}
`;
    if (options.compressed) {
      const gzippedSizeLabel = `${import_picocolors12.default.bold(
        import_picocolors12.default.blue("Gzipped size:")
      )}  ${calcFileSize(totalGzipSize)}`;
      log += `  ${gzippedSizeLabel}
`;
    }
    logs.push(log);
  }
  return logs;
}
var import_node_fs6, import_node_path22, import_node_util2, import_node_zlib2, import_picocolors12, gzip, filterAsset, getAssetColor, calcFileSize, coloringAssetName, pluginFileSize;
var init_fileSize = __esm({
  "src/plugins/fileSize.ts"() {
    "use strict";
    import_node_fs6 = __toESM(require("fs"));
    import_node_path22 = __toESM(require("path"));
    import_node_util2 = require("util");
    import_node_zlib2 = __toESM(require("zlib"));
    import_picocolors12 = __toESM(require("../compiled/picocolors/index.js"));
    init_constants();
    init_logger();
    gzip = (0, import_node_util2.promisify)(import_node_zlib2.default.gzip);
    filterAsset = (asset) => !/\.map$/.test(asset) && !/\.LICENSE\.txt$/.test(asset);
    getAssetColor = (size) => {
      if (size > 300 * 1e3) {
        return import_picocolors12.default.red;
      }
      if (size > 100 * 1e3) {
        return import_picocolors12.default.yellow;
      }
      return import_picocolors12.default.green;
    };
    calcFileSize = (len) => {
      const val = len / 1e3;
      return `${val.toFixed(val < 1 ? 2 : 1)} kB`;
    };
    coloringAssetName = (assetName) => {
      if (JS_REGEX.test(assetName)) {
        return import_picocolors12.default.cyan(assetName);
      }
      if (CSS_REGEX.test(assetName)) {
        return import_picocolors12.default.yellow(assetName);
      }
      if (HTML_REGEX.test(assetName)) {
        return import_picocolors12.default.green(assetName);
      }
      return import_picocolors12.default.magenta(assetName);
    };
    pluginFileSize = () => ({
      name: "rsbuild:file-size",
      setup(api) {
        api.onAfterBuild(async ({ stats, environments, isFirstCompile }) => {
          if (!stats || stats.hasErrors() || !isFirstCompile) {
            return;
          }
          await Promise.all(
            Object.values(environments).map(async (environment, index) => {
              const { printFileSize } = environment.config.performance;
              if (printFileSize === false) {
                return;
              }
              const multiStats = "stats" in stats ? stats.stats : [stats];
              const defaultConfig = {
                total: true,
                detail: true,
                compressed: true
              };
              const mergedConfig = printFileSize === true ? defaultConfig : {
                ...defaultConfig,
                ...printFileSize
              };
              const statsLog = await printFileSizes(
                mergedConfig,
                multiStats[index],
                api.context.rootPath
              );
              const name = import_picocolors12.default.green(environment.name);
              import_rslog.logger.info(`Production file sizes for ${name}:
`);
              for (const log of statsLog) {
                import_rslog.logger.log(log);
              }
            })
          ).catch((err) => {
            import_rslog.logger.warn("Failed to print file size.");
            import_rslog.logger.warn(err);
          });
        });
      }
    });
  }
});

// src/plugins/cleanOutput.ts
var cleanOutput_exports = {};
__export(cleanOutput_exports, {
  dedupeCleanPaths: () => dedupeCleanPaths,
  pluginCleanOutput: () => pluginCleanOutput
});
var import_node_path23, import_picocolors13, addTrailingSep, isStrictSubdir, dedupeCleanPaths, pluginCleanOutput;
var init_cleanOutput = __esm({
  "src/plugins/cleanOutput.ts"() {
    "use strict";
    import_node_path23 = require("path");
    import_picocolors13 = __toESM(require("../compiled/picocolors/index.js"));
    init_constants();
    init_helpers();
    init_logger();
    addTrailingSep = (dir) => dir.endsWith(import_node_path23.sep) ? dir : dir + import_node_path23.sep;
    isStrictSubdir = (parent, child) => {
      const parentDir = addTrailingSep(parent);
      const childDir = addTrailingSep(child);
      return parentDir !== childDir && childDir.startsWith(parentDir);
    };
    dedupeCleanPaths = (paths) => {
      return paths.sort((p1, p2) => p2.length > p1.length ? -1 : 1).reduce((prev, curr) => {
        const isSub = prev.find((p) => curr.startsWith(p) || curr === p);
        if (isSub) {
          return prev;
        }
        return prev.concat(curr);
      }, []);
    };
    pluginCleanOutput = () => ({
      name: "rsbuild:clean-output",
      setup(api) {
        const getRsbuildCleanPath = () => {
          const { rootPath, distPath } = api.context;
          const config = api.getNormalizedConfig();
          const cleanPath = (0, import_node_path23.join)(distPath, RSBUILD_OUTPUTS_PATH);
          const { cleanDistPath } = config.output;
          if (cleanDistPath === true || cleanDistPath === "auto" && isStrictSubdir(rootPath, cleanPath)) {
            return cleanPath;
          }
          return void 0;
        };
        const getCleanPath = (environment) => {
          const { rootPath } = api.context;
          const { config, distPath } = environment;
          let { cleanDistPath } = config.output;
          if (cleanDistPath === "auto") {
            cleanDistPath = isStrictSubdir(rootPath, distPath);
            if (!cleanDistPath) {
              import_rslog.logger.warn(
                "The dist path is not a subdir of root path, Rsbuild will not empty it."
              );
              import_rslog.logger.warn(
                `Please set ${import_picocolors13.default.yellow("`output.cleanDistPath`")} config manually.`
              );
              import_rslog.logger.warn(`Current root path: ${import_picocolors13.default.dim(rootPath)}`);
              import_rslog.logger.warn(`Current dist path: ${import_picocolors13.default.dim(distPath)}`);
            }
          }
          if (cleanDistPath) {
            return distPath;
          }
          return void 0;
        };
        const cleanAll = async (params) => {
          const environments = Object.values(params.environments).reduce((total, curr) => {
            if (!total.find((t) => t.distPath === curr.distPath)) {
              total.push(curr);
            }
            return total;
          }, []);
          const cleanPaths = environments.map((e) => getCleanPath(e)).concat(getRsbuildCleanPath()).filter((p) => !!p);
          await Promise.all(dedupeCleanPaths(cleanPaths).map((p) => emptyDir(p)));
        };
        api.onBeforeBuild(async ({ isFirstCompile, environments }) => {
          if (isFirstCompile) {
            await cleanAll({ environments });
          }
        });
        api.onBeforeStartDevServer(cleanAll);
      }
    });
  }
});

// src/plugins/asset.ts
var asset_exports = {};
__export(asset_exports, {
  getRegExpForExts: () => getRegExpForExts,
  pluginAsset: () => pluginAsset
});
function getRegExpForExts(exts) {
  const matcher = exts.map((ext) => ext.trim()).map((ext) => ext.startsWith(".") ? ext.slice(1) : ext).join("|");
  return new RegExp(
    exts.length === 1 ? `\\.${matcher}$` : `\\.(?:${matcher})$`,
    "i"
  );
}
var import_node_path24, chainStaticAssetRule, pluginAsset;
var init_asset = __esm({
  "src/plugins/asset.ts"() {
    "use strict";
    import_node_path24 = __toESM(require("path"));
    init_constants();
    init_helpers();
    chainStaticAssetRule = ({
      emit,
      rule,
      maxSize,
      filename,
      assetType
    }) => {
      const generatorOptions = {
        filename
      };
      if (emit === false) {
        generatorOptions.emit = false;
      }
      rule.oneOf(`${assetType}-asset-url`).type("asset/resource").resourceQuery(/(__inline=false|url)/).set("generator", generatorOptions);
      rule.oneOf(`${assetType}-asset-inline`).type("asset/inline").resourceQuery(/inline/);
      rule.oneOf(`${assetType}-asset`).type("asset").parser({
        dataUrlCondition: {
          maxSize
        }
      }).set("generator", generatorOptions);
    };
    pluginAsset = () => ({
      name: "rsbuild:asset",
      setup(api) {
        api.modifyBundlerChain((chain, { isProd, environment }) => {
          const { config } = environment;
          const createAssetRule = (assetType, exts, emit) => {
            const regExp = getRegExpForExts(exts);
            const distDir = config.output.distPath[assetType];
            const filename = getFilename(config, assetType, isProd);
            const { dataUriLimit } = config.output;
            const maxSize = typeof dataUriLimit === "number" ? dataUriLimit : dataUriLimit[assetType];
            const rule = chain.module.rule(assetType).test(regExp);
            chainStaticAssetRule({
              emit,
              rule,
              maxSize,
              filename: import_node_path24.default.posix.join(distDir, filename),
              assetType
            });
          };
          const { emitAssets } = config.output;
          createAssetRule("image", IMAGE_EXTENSIONS, emitAssets);
          createAssetRule("svg", ["svg"], emitAssets);
          createAssetRule(
            "media",
            [...VIDEO_EXTENSIONS, ...AUDIO_EXTENSIONS],
            emitAssets
          );
          createAssetRule("font", FONT_EXTENSIONS, emitAssets);
        });
      }
    });
  }
});

// src/rspack/RsbuildHtmlPlugin.ts
var RsbuildHtmlPlugin_exports = {};
__export(RsbuildHtmlPlugin_exports, {
  FILE_ATTRS: () => FILE_ATTRS,
  RsbuildHtmlPlugin: () => RsbuildHtmlPlugin,
  hasTitle: () => hasTitle
});
var import_node_path25, import_node_util3, VOID_TAGS, HEAD_TAGS, FILE_ATTRS, hasTitle, getTagPriority, formatBasicTag, fromBasicTag, formatTags, applyTagConfig, addTitleTag, RsbuildHtmlPlugin;
var init_RsbuildHtmlPlugin = __esm({
  "src/rspack/RsbuildHtmlPlugin.ts"() {
    "use strict";
    import_node_path25 = __toESM(require("path"));
    import_node_util3 = require("util");
    init_helpers();
    init_pluginHelper();
    VOID_TAGS = [
      "area",
      "base",
      "br",
      "col",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    HEAD_TAGS = [
      "title",
      "base",
      "link",
      "style",
      "meta",
      "script",
      "noscript",
      "template"
    ];
    FILE_ATTRS = {
      link: "href",
      script: "src"
    };
    hasTitle = (html) => html ? /<title/i.test(html) && /<\/title/i.test(html) : false;
    getTagPriority = (tag, tagConfig) => {
      const head = tag.head ?? HEAD_TAGS.includes(tag.tag);
      let priority = head ? -2 : 2;
      const append = tag.append ?? tagConfig.append;
      if (typeof append === "boolean") {
        priority += append ? 1 : -1;
      }
      return priority;
    };
    formatBasicTag = (tag) => ({
      tag: tag.tagName,
      attrs: tag.attributes,
      children: tag.innerHTML
    });
    fromBasicTag = (tag) => ({
      meta: {},
      tagName: tag.tag,
      attributes: tag.attrs ?? {},
      voidTag: VOID_TAGS.includes(tag.tag),
      innerHTML: tag.children
    });
    formatTags = (tags, override) => tags.map((tag) => ({
      ...formatBasicTag(tag),
      publicPath: false,
      ...override
    }));
    applyTagConfig = (data, tagConfig, compilationHash, entryName) => {
      if (!tagConfig.tags?.length) {
        return data;
      }
      const fromInjectTags = (tags2) => {
        const ret = [];
        for (const tag of tags2) {
          const attrs = { ...tag.attrs };
          const filenameTag = FILE_ATTRS[tag.tag];
          let filename = attrs[filenameTag];
          if (typeof filename === "string") {
            const optPublicPath = tag.publicPath ?? tagConfig.publicPath;
            if (typeof optPublicPath === "function") {
              filename = optPublicPath(filename, data.publicPath);
            } else if (typeof optPublicPath === "string") {
              filename = ensureAssetPrefix(filename, optPublicPath);
            } else if (optPublicPath !== false) {
              filename = ensureAssetPrefix(filename, data.publicPath);
            }
            const optHash = tag.hash ?? tagConfig.hash;
            if (typeof optHash === "function") {
              if (compilationHash.length) {
                filename = optHash(filename, compilationHash);
              }
            } else if (typeof optHash === "string") {
              if (optHash.length) {
                filename = `${filename}?${optHash}`;
              }
            } else if (optHash === true) {
              if (compilationHash.length) {
                filename = `${filename}?${compilationHash}`;
              }
            }
            attrs[filenameTag] = filename;
            tag.attrs = attrs;
          }
          ret.push(fromBasicTag(tag));
        }
        return ret;
      };
      let tags = [
        ...formatTags(data.headTags, { head: true }),
        ...formatTags(data.bodyTags, { head: false })
      ];
      const context = {
        hash: compilationHash,
        entryName,
        outputName: data.outputName,
        publicPath: data.publicPath
      };
      for (const item of tagConfig.tags) {
        if (isFunction(item)) {
          tags = item(tags, context) || tags;
        } else {
          tags.push(item);
        }
        tags = tags.sort(
          (tag1, tag2) => getTagPriority(tag1, tagConfig) - getTagPriority(tag2, tagConfig)
        );
      }
      const [headTags, bodyTags] = partition(
        tags,
        (tag) => tag.head ?? HEAD_TAGS.includes(tag.tag)
      );
      data.headTags = fromInjectTags(headTags);
      data.bodyTags = fromInjectTags(bodyTags);
      return data;
    };
    addTitleTag = (headTags, title = "") => {
      headTags.unshift({
        tagName: "title",
        innerHTML: title,
        attributes: {},
        voidTag: false,
        meta: {}
      });
    };
    RsbuildHtmlPlugin = class {
      constructor(options, getEnvironment, modifyTagsFn) {
        __publicField(this, "name");
        __publicField(this, "getEnvironment");
        __publicField(this, "options");
        __publicField(this, "modifyTagsFn");
        this.name = "RsbuildHtmlPlugin";
        this.options = options;
        this.modifyTagsFn = modifyTagsFn;
        this.getEnvironment = getEnvironment;
      }
      apply(compiler) {
        const emitFavicon = async (compilation, favicon) => {
          const name = import_node_path25.default.basename(favicon);
          if (compilation.assets[name]) {
            return name;
          }
          if (!compilation.inputFileSystem) {
            throw new Error(
              `[RsbuildHtmlPlugin] 'compilation.inputFileSystem' is not available.`
            );
          }
          const filename = import_node_path25.default.resolve(compilation.compiler.context, favicon);
          const buf = await (0, import_node_util3.promisify)(compilation.inputFileSystem.readFile)(
            filename
          );
          if (!buf) {
            throw new Error(
              `[RsbuildHtmlPlugin] Failed to read the favicon, please check if the '${filename}' file exists'.`
            );
          }
          const source = new compiler.webpack.sources.RawSource(buf, false);
          compilation.emitAsset(name, source);
          return name;
        };
        const addFavicon = async (headTags, favicon, compilation, publicPath) => {
          let href = favicon;
          if (!isURL(favicon)) {
            const name = await emitFavicon(compilation, favicon);
            href = ensureAssetPrefix(name, publicPath);
          }
          const tag = {
            tagName: "link",
            voidTag: true,
            attributes: {
              rel: "icon",
              href
            },
            meta: {}
          };
          if (href.endsWith(".svg")) {
            tag.attributes.type = "image/svg+xml";
          }
          headTags.unshift(tag);
        };
        compiler.hooks.compilation.tap(this.name, (compilation) => {
          getHTMLPlugin().getHooks(compilation).alterAssetTagGroups.tapPromise(this.name, async (data) => {
            const entryName = data.plugin.options?.entryName;
            if (!entryName) {
              return data;
            }
            const { headTags, bodyTags } = data;
            const { favicon, tagConfig, templateContent } = this.options[entryName];
            if (!hasTitle(templateContent)) {
              addTitleTag(headTags, data.plugin.options?.title);
            }
            if (favicon) {
              await addFavicon(headTags, favicon, compilation, data.publicPath);
            }
            const tags = {
              headTags: headTags.map(formatBasicTag),
              bodyTags: bodyTags.map(formatBasicTag)
            };
            const modified = this.modifyTagsFn ? await this.modifyTagsFn(tags, {
              compiler,
              compilation,
              assetPrefix: data.publicPath,
              filename: data.outputName,
              environment: this.getEnvironment()
            }) : tags;
            Object.assign(data, {
              headTags: modified.headTags.map(fromBasicTag),
              bodyTags: modified.bodyTags.map(fromBasicTag)
            });
            if (tagConfig) {
              const hash = compilation.hash ?? "";
              applyTagConfig(data, tagConfig, hash, entryName);
            }
            return data;
          });
        });
      }
    };
  }
});

// src/plugins/html.ts
var html_exports = {};
__export(html_exports, {
  getTemplate: () => getTemplate,
  pluginHtml: () => pluginHtml
});
function getTitle(entryName, config) {
  return reduceConfigsMergeContext({
    initial: "",
    config: config.html.title,
    ctx: { entryName }
  });
}
function getInject(entryName, config) {
  return reduceConfigsMergeContext({
    initial: "head",
    config: config.html.inject,
    ctx: { entryName }
  });
}
async function getTemplate(entryName, config, rootPath) {
  const templatePath = reduceConfigsMergeContext({
    initial: "",
    config: config.html.template,
    ctx: { entryName }
  });
  if (!templatePath) {
    return {
      templatePath: void 0,
      templateContent: getDefaultTemplateContent(config.html.mountId)
    };
  }
  const absolutePath = (0, import_node_path26.isAbsolute)(templatePath) ? templatePath : import_node_path26.default.resolve(rootPath, templatePath);
  if (!existTemplatePath.has(absolutePath)) {
    if (!await isFileExists(absolutePath)) {
      throw new Error(
        `Failed to resolve HTML template, please check if the file exists: ${import_picocolors14.default.cyan(
          absolutePath
        )}`
      );
    }
    existTemplatePath.add(absolutePath);
  }
  const templateContent = await import_node_fs7.default.promises.readFile(absolutePath, "utf-8");
  return {
    templatePath: absolutePath,
    templateContent
  };
}
function getFavicon(entryName, config) {
  return reduceConfigsMergeContext({
    initial: "",
    config: config.html.favicon,
    ctx: { entryName }
  });
}
function getMetaTags(entryName, config, templateContent) {
  const metaTags = reduceConfigsMergeContext({
    initial: {},
    config: config.html.meta,
    ctx: { entryName }
  });
  if (templateContent && metaTags.charset) {
    const charsetRegExp = /<meta[^>]+charset=["'][^>]*>/i;
    if (charsetRegExp.test(templateContent)) {
      delete metaTags.charset;
    }
  }
  return metaTags;
}
function getTemplateParameters(entryName, config, assetPrefix) {
  return (compilation, assets, assetTags, pluginOptions) => {
    const { mountId, templateParameters } = config.html;
    const rspackConfig = compilation.options;
    const htmlPlugin2 = {
      tags: assetTags,
      files: assets,
      options: pluginOptions
    };
    const defaultOptions2 = {
      mountId,
      entryName,
      assetPrefix,
      compilation,
      htmlPlugin: htmlPlugin2,
      rspackConfig,
      /**
       * compatible with html-webpack-plugin
       * @deprecated may be removed in a future major version, use `rspackConfig` instead
       */
      webpackConfig: rspackConfig,
      /**
       * compatible with html-webpack-plugin
       * @deprecated may be removed in a future major version, use `htmlPlugin` instead
       */
      htmlWebpackPlugin: htmlPlugin2
    };
    return reduceConfigsWithContext({
      initial: defaultOptions2,
      config: templateParameters,
      ctx: { entryName }
    });
  };
}
function getChunks(entryName, entryValue) {
  const chunks = [entryName];
  for (const item of entryValue) {
    if (!isPlainObject(item)) {
      continue;
    }
    const { dependOn } = item;
    if (!dependOn) {
      continue;
    }
    if (typeof dependOn === "string") {
      chunks.unshift(dependOn);
    } else {
      chunks.unshift(...dependOn);
    }
  }
  return chunks;
}
var import_node_fs7, import_node_path26, import_picocolors14, getDefaultTemplateContent, existTemplatePath, getTagConfig, pluginHtml;
var init_html = __esm({
  "src/plugins/html.ts"() {
    "use strict";
    import_node_fs7 = __toESM(require("fs"));
    import_node_path26 = __toESM(require("path"));
    import_picocolors14 = __toESM(require("../compiled/picocolors/index.js"));
    init_dist();
    init_helpers();
    getDefaultTemplateContent = (mountId) => `<!doctype html><html><head></head><body><div id="${mountId}"></div></body></html>`;
    existTemplatePath = /* @__PURE__ */ new Set();
    getTagConfig = (config) => {
      const tags = castArray(config.html.tags).filter(Boolean);
      if (!tags.length) {
        return void 0;
      }
      return {
        append: true,
        hash: false,
        publicPath: true,
        tags
      };
    };
    pluginHtml = (modifyTagsFn) => ({
      name: "rsbuild:html",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { HtmlPlugin, CHAIN_ID: CHAIN_ID2, environment }) => {
            const { config, htmlPaths } = environment;
            if (Object.keys(htmlPaths).length === 0) {
              return;
            }
            const assetPrefix = getPublicPathFromChain(chain, false);
            const entries = chain.entryPoints.entries() || {};
            const entryNames = Object.keys(entries).filter(
              (entryName) => Boolean(htmlPaths[entryName])
            );
            const htmlInfoMap = {};
            const finalOptions = await Promise.all(
              entryNames.map(async (entryName) => {
                const entryValue = entries[entryName].values();
                const chunks = getChunks(entryName, entryValue);
                const inject = getInject(entryName, config);
                const filename = htmlPaths[entryName];
                const { templatePath, templateContent } = await getTemplate(
                  entryName,
                  config,
                  api.context.rootPath
                );
                const templateParameters = getTemplateParameters(
                  entryName,
                  config,
                  assetPrefix
                );
                const metaTags = getMetaTags(entryName, config, templateContent);
                const pluginOptions = {
                  meta: metaTags,
                  chunks,
                  inject,
                  filename,
                  entryName,
                  templateParameters,
                  scriptLoading: config.html.scriptLoading
                };
                if (templatePath) {
                  pluginOptions.template = templatePath;
                }
                if (chunks.length > 1) {
                  pluginOptions.chunksSortMode = "manual";
                }
                const htmlInfo = {};
                htmlInfoMap[entryName] = htmlInfo;
                if (templateContent) {
                  htmlInfo.templateContent = templateContent;
                }
                const tagConfig = getTagConfig(environment.config);
                if (tagConfig) {
                  htmlInfo.tagConfig = tagConfig;
                }
                pluginOptions.title = getTitle(entryName, config);
                const favicon = getFavicon(entryName, config);
                if (favicon) {
                  htmlInfo.favicon = favicon;
                }
                const finalOptions2 = reduceConfigsWithContext({
                  initial: pluginOptions,
                  config: typeof config.tools.htmlPlugin === "boolean" ? {} : config.tools.htmlPlugin,
                  ctx: { entryName, entryValue }
                });
                if (!finalOptions2.template && !finalOptions2.templateContent) {
                  pluginOptions.template = "";
                  pluginOptions.templateContent = templateContent;
                }
                return finalOptions2;
              })
            );
            entryNames.forEach((entryName, index) => {
              chain.plugin(`${CHAIN_ID2.PLUGIN.HTML}-${entryName}`).use(HtmlPlugin, [finalOptions[index]]);
            });
            const { RsbuildHtmlPlugin: RsbuildHtmlPlugin2 } = await Promise.resolve().then(() => (init_RsbuildHtmlPlugin(), RsbuildHtmlPlugin_exports));
            chain.plugin("rsbuild-html-plugin").use(RsbuildHtmlPlugin2, [
              htmlInfoMap,
              () => environment,
              modifyTagsFn?.(environment.name)
            ]);
            if (config.html) {
              const { crossorigin } = config.html;
              if (crossorigin) {
                const formattedCrossorigin = crossorigin === true ? "anonymous" : crossorigin;
                chain.output.crossOriginLoading(formattedCrossorigin);
              }
            }
          }
        );
        api.modifyHTMLTags({
          // ensure `crossorigin` and `nonce` can be applied to all tags
          order: "post",
          handler: ({ headTags, bodyTags }, { environment }) => {
            const { config } = environment;
            const { crossorigin } = config.html;
            const allTags = [...headTags, ...bodyTags];
            if (crossorigin) {
              const formattedCrossorigin = crossorigin === true ? "anonymous" : crossorigin;
              for (const tag of allTags) {
                if (tag.tag === "script" && tag.attrs?.src || tag.tag === "link" && tag.attrs?.rel === "stylesheet") {
                  tag.attrs.crossorigin ??= formattedCrossorigin;
                }
              }
            }
            return { headTags, bodyTags };
          }
        });
      }
    });
  }
});

// src/plugins/appIcon.ts
var appIcon_exports = {};
__export(appIcon_exports, {
  pluginAppIcon: () => pluginAppIcon
});
var import_node_path27, import_node_util4, import_mrmime, pluginAppIcon;
var init_appIcon = __esm({
  "src/plugins/appIcon.ts"() {
    "use strict";
    import_node_path27 = __toESM(require("path"));
    import_node_util4 = require("util");
    import_mrmime = require("../compiled/mrmime/index.js");
    init_helpers();
    pluginAppIcon = () => ({
      name: "rsbuild:app-icon",
      setup(api) {
        const htmlTagsMap = /* @__PURE__ */ new Map();
        const iconFormatMap = /* @__PURE__ */ new Map();
        const formatIcon = (icon, distDir, publicPath) => {
          const { src, size } = icon;
          const cached = iconFormatMap.get(src);
          if (cached) {
            return { ...cached, ...icon };
          }
          const sizes = `${size}x${size}`;
          if (isURL(src)) {
            const paths2 = {
              sizes,
              isURL: true,
              requestPath: src,
              absolutePath: src,
              relativePath: src,
              mimeType: (0, import_mrmime.lookup)(src)
            };
            iconFormatMap.set(src, paths2);
            return { ...paths2, ...icon };
          }
          const absolutePath = import_node_path27.default.isAbsolute(src) ? src : import_node_path27.default.join(api.context.rootPath, src);
          const relativePath = import_node_path27.default.posix.join(
            distDir,
            import_node_path27.default.basename(absolutePath)
          );
          const requestPath = ensureAssetPrefix(relativePath, publicPath);
          const paths = {
            sizes,
            requestPath,
            absolutePath,
            relativePath,
            mimeType: (0, import_mrmime.lookup)(absolutePath)
          };
          iconFormatMap.set(src, paths);
          return { ...paths, ...icon };
        };
        api.processAssets(
          { stage: "additional" },
          async ({ compilation, environment, sources }) => {
            const { config } = environment;
            const { appIcon } = config.html;
            if (!appIcon) {
              return;
            }
            const distDir = config.output.distPath.image;
            const manifestFile = appIcon.filename ?? "manifest.webmanifest";
            const publicPath = getPublicPathFromCompiler(compilation);
            const icons = appIcon.icons.map(
              (icon) => formatIcon(icon, distDir, publicPath)
            );
            const tags = [];
            for (const icon of icons) {
              if (icon.target === "web-app-manifest" && !appIcon.name) {
                throw new Error(
                  "[rsbuild:app-icon] `appIcon.name` is required when `target` is 'web-app-manifest'."
                );
              }
              if (!icon.isURL) {
                if (!compilation.inputFileSystem) {
                  throw new Error(
                    `[rsbuild:app-icon] 'compilation.inputFileSystem' is not available.`
                  );
                }
                if (!await fileExistsByCompilation(compilation, icon.absolutePath)) {
                  throw new Error(
                    `[rsbuild:app-icon] Can not find the app icon, please check if the '${icon.relativePath}' file exists'.`
                  );
                }
                const source = await (0, import_node_util4.promisify)(
                  compilation.inputFileSystem.readFile
                )(icon.absolutePath);
                if (!source) {
                  throw new Error(
                    `[rsbuild:app-icon] Failed to read the app icon file, please check if the '${icon.relativePath}' file exists'.`
                  );
                }
                compilation.emitAsset(
                  icon.relativePath,
                  new sources.RawSource(source)
                );
              }
              if (icon.target === "apple-touch-icon" || !icon.target && icon.size < 200) {
                tags.push({
                  tag: "link",
                  attrs: {
                    rel: "apple-touch-icon",
                    sizes: icon.sizes,
                    href: icon.requestPath
                  }
                });
              }
            }
            if (appIcon.name) {
              const manifestIcons = icons.filter(
                (icon) => icon.target === "web-app-manifest" || !icon.target
              ).map((icon) => {
                const result = {
                  src: icon.requestPath,
                  sizes: icon.sizes
                };
                if (icon.mimeType) {
                  return { ...result, type: icon.mimeType };
                }
                return result;
              });
              const manifest = {
                name: appIcon.name,
                icons: manifestIcons
              };
              compilation.emitAsset(
                manifestFile,
                new sources.RawSource(JSON.stringify(manifest))
              );
              tags.push({
                tag: "link",
                attrs: {
                  rel: "manifest",
                  href: ensureAssetPrefix(manifestFile, publicPath)
                }
              });
            }
            if (tags.length) {
              htmlTagsMap.set(environment.name, tags);
            }
          }
        );
        api.modifyHTMLTags(({ headTags, bodyTags }, { environment }) => {
          const tags = htmlTagsMap.get(environment.name);
          if (tags) {
            headTags.unshift(...tags);
          }
          return { headTags, bodyTags };
        });
        api.onCloseDevServer(() => {
          htmlTagsMap.clear();
          iconFormatMap.clear();
        });
      }
    });
  }
});

// src/plugins/wasm.ts
var wasm_exports = {};
__export(wasm_exports, {
  pluginWasm: () => pluginWasm
});
var import_node_path28, pluginWasm;
var init_wasm = __esm({
  "src/plugins/wasm.ts"() {
    "use strict";
    import_node_path28 = require("path");
    pluginWasm = () => ({
      name: "rsbuild:wasm",
      setup(api) {
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
          const { config } = environment;
          const distPath = config.output.distPath.wasm;
          chain.experiments({
            ...chain.get("experiments"),
            asyncWebAssembly: true
          });
          const wasmFilename = import_node_path28.posix.join(distPath, "[hash].module.wasm");
          chain.output.merge({
            webassemblyModuleFilename: wasmFilename
          });
          chain.module.rule(CHAIN_ID2.RULE.WASM).test(/\.wasm$/).merge({
            dependency: "url"
          }).type("asset/resource").set("generator", {
            filename: wasmFilename
          });
        });
      }
    });
  }
});

// src/plugins/moment.ts
var moment_exports = {};
__export(moment_exports, {
  pluginMoment: () => pluginMoment
});
var pluginMoment;
var init_moment = __esm({
  "src/plugins/moment.ts"() {
    "use strict";
    pluginMoment = () => ({
      name: "rsbuild:moment",
      setup(api) {
        api.modifyBundlerChain(async (chain, { environment, bundler }) => {
          const { config } = environment;
          if (config.performance.removeMomentLocale) {
            chain.plugin("remove-moment-locale").use(bundler.IgnorePlugin, [
              {
                resourceRegExp: /^\.\/locale$/,
                contextRegExp: /moment$/
              }
            ]);
          }
        });
      }
    });
  }
});

// src/plugins/nodeAddons.ts
var nodeAddons_exports = {};
__export(nodeAddons_exports, {
  pluginNodeAddons: () => pluginNodeAddons
});
var import_node_path29, getFilename2, pluginNodeAddons;
var init_nodeAddons = __esm({
  "src/plugins/nodeAddons.ts"() {
    "use strict";
    import_node_path29 = __toESM(require("path"));
    getFilename2 = (resourcePath) => {
      let basename = "";
      if (resourcePath) {
        const parsed = import_node_path29.default.parse(resourcePath);
        if (parsed.dir) {
          basename = parsed.name;
        }
      }
      if (basename) {
        return `${basename}.node`;
      }
      return null;
    };
    pluginNodeAddons = () => ({
      name: "rsbuild:node-addons",
      setup(api) {
        api.transform(
          { test: /\.node$/, targets: ["node"], raw: true },
          ({ code, emitFile, resourcePath }) => {
            const name = getFilename2(resourcePath);
            if (name === null) {
              throw new Error(`Failed to load Node.js addon: "${resourcePath}"`);
            }
            emitFile(name, code);
            return `
try {
const path = require("path");
process.dlopen(module, path.join(__dirname, "${name}"));
} catch (error) {
throw new Error('Failed to load Node.js addon: "${name}"\\n' + error);
}
`;
          }
        );
      }
    });
  }
});

// src/plugins/define.ts
var define_exports = {};
__export(define_exports, {
  pluginDefine: () => pluginDefine
});
var pluginDefine;
var init_define = __esm({
  "src/plugins/define.ts"() {
    "use strict";
    init_helpers();
    pluginDefine = () => ({
      name: "rsbuild:define",
      setup(api) {
        api.modifyBundlerChain((chain, { CHAIN_ID: CHAIN_ID2, bundler, environment }) => {
          const { config } = environment;
          const builtinVars = {
            "import.meta.env.MODE": JSON.stringify(config.mode),
            "import.meta.env.DEV": config.mode === "development",
            "import.meta.env.PROD": config.mode === "production",
            "process.env.ASSET_PREFIX": JSON.stringify(
              getPublicPathFromChain(chain, false)
            )
          };
          chain.plugin(CHAIN_ID2.PLUGIN.DEFINE).use(bundler.DefinePlugin, [
            { ...builtinVars, ...config.source.define }
          ]);
        });
      }
    });
  }
});

// src/plugins/minimize.ts
var minimize_exports = {};
__export(minimize_exports, {
  getSwcMinimizerOptions: () => getSwcMinimizerOptions,
  parseMinifyOptions: () => parseMinifyOptions,
  pluginMinimize: () => pluginMinimize
});
var import_core6, import_deepmerge3, getSwcMinimizerOptions, parseMinifyOptions, pluginMinimize;
var init_minimize = __esm({
  "src/plugins/minimize.ts"() {
    "use strict";
    import_core6 = require("@rspack/core");
    import_deepmerge3 = __toESM(require_cjs());
    getSwcMinimizerOptions = (config, jsOptions) => {
      const options = {};
      options.minimizerOptions ||= {};
      options.minimizerOptions.format ||= {};
      const { removeConsole } = config.performance;
      if (removeConsole === true) {
        options.minimizerOptions.compress = {
          drop_console: true
        };
      } else if (Array.isArray(removeConsole)) {
        const pureFuncs = removeConsole.map((method) => `console.${method}`);
        options.minimizerOptions.compress = {
          pure_funcs: pureFuncs
        };
      }
      switch (config.output.legalComments) {
        case "inline":
          options.minimizerOptions.format.comments = "some";
          options.extractComments = false;
          break;
        case "linked":
          options.extractComments = true;
          break;
        case "none":
          options.minimizerOptions.format.comments = false;
          options.extractComments = false;
          break;
        default:
          break;
      }
      options.minimizerOptions.format.asciiOnly = config.output.charset === "ascii";
      if (jsOptions) {
        return (0, import_deepmerge3.default)(options, jsOptions);
      }
      return options;
    };
    parseMinifyOptions = (config, isProd) => {
      const { minify } = config.output;
      if (minify === false || !isProd) {
        return {
          minifyJs: false,
          minifyCss: false
        };
      }
      if (minify === true) {
        return {
          minifyJs: true,
          minifyCss: true
        };
      }
      return {
        minifyJs: minify.js !== false,
        minifyCss: minify.css !== false,
        jsOptions: minify.jsOptions,
        cssOptions: minify.cssOptions
      };
    };
    pluginMinimize = () => ({
      name: "rsbuild:minimize",
      setup(api) {
        const isRspack = api.context.bundlerType === "rspack";
        api.modifyBundlerChain(async (chain, { isProd, environment, CHAIN_ID: CHAIN_ID2 }) => {
          const { config } = environment;
          const { minifyJs, minifyCss, jsOptions, cssOptions } = parseMinifyOptions(
            config,
            isProd
          );
          chain.optimization.minimize(minifyJs || minifyCss);
          if (minifyJs && isRspack) {
            chain.optimization.minimizer(CHAIN_ID2.MINIMIZER.JS).use(import_core6.rspack.SwcJsMinimizerRspackPlugin, [
              getSwcMinimizerOptions(config, jsOptions)
            ]).end();
          }
          if (minifyCss && isRspack) {
            const defaultOptions2 = {
              minimizerOptions: {
                targets: environment.browserslist,
                // TODO: The exclude option of Lightning CSS does not work as expected
                // so we need to disable all excludes and figure out how to skip the transformation
                // see: https://github.com/parcel-bundler/lightningcss/issues/792
                exclude: {
                  nesting: false,
                  notSelectorList: false,
                  dirSelector: false,
                  langSelectorList: false,
                  isSelector: false,
                  textDecorationThicknessPercent: false,
                  mediaIntervalSyntax: false,
                  mediaRangeSyntax: false,
                  customMediaQueries: false,
                  clampFunction: false,
                  colorFunction: false,
                  oklabColors: false,
                  labColors: false,
                  p3Colors: false,
                  hexAlphaColors: false,
                  spaceSeparatedColorNotation: false,
                  fontFamilySystemUi: false,
                  doublePositionGradients: false,
                  vendorPrefixes: false,
                  logicalProperties: false,
                  selectors: false,
                  mediaQueries: false,
                  color: false
                }
              }
            };
            const mergedOptions = cssOptions ? (0, import_deepmerge3.default)(
              defaultOptions2,
              cssOptions
            ) : defaultOptions2;
            chain.optimization.minimizer(CHAIN_ID2.MINIMIZER.CSS).use(import_core6.rspack.LightningCssMinimizerRspackPlugin, [mergedOptions]).end();
          }
        });
      }
    });
  }
});

// src/plugins/progress.ts
var progress_exports = {};
__export(progress_exports, {
  pluginProgress: () => pluginProgress
});
var import_core7, pluginProgress;
var init_progress = __esm({
  "src/plugins/progress.ts"() {
    "use strict";
    import_core7 = require("@rspack/core");
    pluginProgress = () => ({
      name: "rsbuild:progress",
      setup(api) {
        if (api.context.bundlerType === "webpack") {
          return;
        }
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
          const { config } = environment;
          const options = config.dev.progressBar ?? // enable progress bar in production mode by default
          config.mode === "production";
          if (!options) {
            return;
          }
          const prefix = options !== true && options.id !== void 0 ? options.id : environment.name;
          chain.plugin(CHAIN_ID2.PLUGIN.PROGRESS).use(import_core7.rspack.ProgressPlugin, [
            {
              prefix,
              ...options === true ? {} : options
            }
          ]);
        });
      }
    });
  }
});

// src/plugins/swc.ts
var swc_exports = {};
__export(swc_exports, {
  applySwcDecoratorConfig: () => applySwcDecoratorConfig,
  pluginSwc: () => pluginSwc
});
function applyScriptCondition({
  rule,
  chain,
  config,
  context,
  includes,
  excludes
}) {
  rule.include.add({
    and: [context.rootPath, { not: NODE_MODULES_REGEX }]
  });
  rule.include.add(/\.(?:ts|tsx|jsx|mts|cts)$/);
  const target = castArray(chain.get("target"));
  const legacyTarget = ["es5", "es6", "es2015", "es2016"];
  if (legacyTarget.some((item) => target.includes(item))) {
    rule.include.add(/[\\/]@rsbuild[\\/]core[\\/]dist[\\/]/);
  }
  for (const condition of [...includes, ...config.source.include || []]) {
    rule.include.add(condition);
  }
  for (const condition of [...excludes, ...config.source.exclude || []]) {
    rule.exclude.add(condition);
  }
}
function getDefaultSwcConfig(browserslist3, cacheRoot) {
  return {
    jsc: {
      externalHelpers: true,
      parser: {
        tsx: false,
        syntax: "typescript",
        decorators: true
      },
      // Avoid the webpack magic comment to be removed
      // https://github.com/swc-project/swc/issues/6403
      preserveAllComments: true,
      experimental: {
        cacheRoot
      }
    },
    isModule: "unknown",
    env: {
      targets: browserslist3
    }
  };
}
async function applyCoreJs(swcConfig, polyfillMode) {
  const coreJsPath = require.resolve("core-js/package.json");
  const version2 = getCoreJsVersion(coreJsPath);
  const coreJsDir = import_node_path30.default.dirname(coreJsPath);
  swcConfig.env.coreJs = version2;
  if (polyfillMode === "usage") {
    swcConfig.env.shippedProposals = true;
  }
  return coreJsDir;
}
function applyTransformImport(swcConfig, pluginImport) {
  const finalPluginImport = reduceTransformImportConfig(pluginImport);
  if (finalPluginImport?.length) {
    swcConfig.rspackExperiments ??= {};
    swcConfig.rspackExperiments.import ??= [];
    swcConfig.rspackExperiments.import.push(...finalPluginImport);
  }
}
function applySwcDecoratorConfig(swcConfig, config) {
  swcConfig.jsc ||= {};
  swcConfig.jsc.transform ||= {};
  const { version: version2 } = config.source.decorators;
  switch (version2) {
    case "legacy":
      swcConfig.jsc.transform.legacyDecorator = true;
      swcConfig.jsc.transform.decoratorMetadata = true;
      swcConfig.jsc.transform.useDefineForClassFields = false;
      break;
    case "2022-03":
      swcConfig.jsc.transform.legacyDecorator = false;
      swcConfig.jsc.transform.decoratorVersion = "2022-03";
      break;
    default:
      throw new Error(`Unknown decorators version: ${version2}`);
  }
}
var import_node_fs8, import_node_path30, import_deepmerge4, builtinSwcLoaderName, pluginSwc, getCoreJsVersion, reduceTransformImportConfig;
var init_swc = __esm({
  "src/plugins/swc.ts"() {
    "use strict";
    import_node_fs8 = __toESM(require("fs"));
    import_node_path30 = __toESM(require("path"));
    import_deepmerge4 = __toESM(require_cjs());
    init_dist();
    init_constants();
    init_helpers();
    builtinSwcLoaderName = "builtin:swc-loader";
    pluginSwc = () => ({
      name: PLUGIN_SWC_NAME,
      setup(api) {
        api.modifyBundlerChain({
          order: "pre",
          handler: async (chain, { CHAIN_ID: CHAIN_ID2, target, environment }) => {
            const { config, browserslist: browserslist3 } = environment;
            const cacheRoot = import_node_path30.default.join(api.context.cachePath, ".swc");
            const rule = chain.module.rule(CHAIN_ID2.RULE.JS).test(SCRIPT_REGEX).type("javascript/auto");
            const dataUriRule = chain.module.rule(CHAIN_ID2.RULE.JS_DATA_URI).mimetype({
              or: ["text/javascript", "application/javascript"]
            });
            applyScriptCondition({
              rule,
              chain,
              config,
              context: api.context,
              includes: [],
              excludes: []
            });
            if (api.context.bundlerType === "webpack") {
              return;
            }
            const swcConfig = getDefaultSwcConfig(browserslist3, cacheRoot);
            applyTransformImport(swcConfig, config.source.transformImport);
            applySwcDecoratorConfig(swcConfig, config);
            if (swcConfig.jsc?.externalHelpers) {
              chain.resolve.alias.set(
                "@swc/helpers",
                import_node_path30.default.dirname(require.resolve("@swc/helpers/package.json"))
              );
            }
            if (isWebTarget(target)) {
              const polyfillMode = config.output.polyfill;
              if (polyfillMode === "off") {
                swcConfig.env.mode = void 0;
              } else {
                swcConfig.env.mode = polyfillMode;
                const coreJsDir = await applyCoreJs(swcConfig, polyfillMode);
                for (const item of [rule, dataUriRule]) {
                  item.resolve.alias.set("core-js", coreJsDir);
                }
              }
            }
            const mergedSwcConfig = reduceConfigs({
              initial: swcConfig,
              config: config.tools.swc,
              mergeFn: import_deepmerge4.default
            });
            rule.use(CHAIN_ID2.USE.SWC).loader(builtinSwcLoaderName).options(mergedSwcConfig);
            dataUriRule.resolve.set("fullySpecified", false).end().use(CHAIN_ID2.USE.SWC).loader(builtinSwcLoaderName).options(cloneDeep(mergedSwcConfig));
          }
        });
      }
    });
    getCoreJsVersion = (corejsPkgPath) => {
      try {
        const rawJson = import_node_fs8.default.readFileSync(corejsPkgPath, "utf-8");
        const { version: version2 } = JSON.parse(rawJson);
        const [major, minor] = version2.split(".");
        return `${major}.${minor}`;
      } catch (err) {
        return "3";
      }
    };
    reduceTransformImportConfig = (options) => {
      if (!options) {
        return [];
      }
      let imports = [];
      for (const item of castArray(options)) {
        if (isFunction(item)) {
          imports = item(imports) ?? imports;
        } else {
          imports.push(item);
        }
      }
      return imports;
    };
  }
});

// src/plugins/externals.ts
var externals_exports = {};
__export(externals_exports, {
  pluginExternals: () => pluginExternals
});
function pluginExternals() {
  return {
    name: "rsbuild:externals",
    setup(api) {
      api.modifyBundlerChain((chain, { environment }) => {
        const { externals } = environment.config.output;
        if (externals) {
          chain.externals(externals);
        }
      });
      api.onBeforeCreateCompiler(({ bundlerConfigs }) => {
        for (const config of bundlerConfigs) {
          const isWebWorker = Array.isArray(config.target) ? config.target.includes("webworker") : config.target === "webworker";
          if (isWebWorker && config.externals) {
            delete config.externals;
          }
        }
      });
    }
  };
}
var init_externals = __esm({
  "src/plugins/externals.ts"() {
    "use strict";
  }
});

// src/plugins/splitChunks.ts
var splitChunks_exports = {};
__export(splitChunks_exports, {
  MODULE_PATH_REGEX: () => MODULE_PATH_REGEX,
  getPackageNameFromModulePath: () => getPackageNameFromModulePath,
  pluginSplitChunks: () => pluginSplitChunks
});
function getForceSplittingGroups(forceSplitting) {
  const cacheGroups = {};
  const pairs = Array.isArray(forceSplitting) ? forceSplitting.map(
    (regexp, index) => [`force-split-${index}`, regexp]
  ) : Object.entries(forceSplitting);
  for (const [key, regexp] of pairs) {
    cacheGroups[key] = {
      test: regexp,
      name: key,
      chunks: "all",
      priority: 0,
      // Ignore minimum size, minimum chunks and maximum requests and always create chunks.
      enforce: true
    };
  }
  return cacheGroups;
}
function splitByExperience(ctx) {
  const { override, polyfill, defaultConfig, forceSplittingGroups } = ctx;
  const experienceCacheGroup = {};
  const packageRegExps = {
    axios: /node_modules[\\/]axios(-.+)?[\\/]/
  };
  if (polyfill === "entry" || polyfill === "usage") {
    packageRegExps.polyfill = /node_modules[\\/](?:tslib|core-js|@swc[\\/]helpers)[\\/]/;
  }
  for (const [name, test] of Object.entries(packageRegExps)) {
    const key = `lib-${name}`;
    experienceCacheGroup[key] = {
      test,
      priority: 0,
      name: key
    };
  }
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...experienceCacheGroup,
      ...forceSplittingGroups,
      ...override.cacheGroups
    }
  };
}
function getPackageNameFromModulePath(modulePath) {
  const handleModuleContext = modulePath?.match(MODULE_PATH_REGEX);
  if (!handleModuleContext) {
    return void 0;
  }
  const [, scope, name] = handleModuleContext;
  const packageName = ["npm", (scope ?? "").replace("@", ""), name].filter(Boolean).join(".");
  return packageName;
}
function splitByModule(ctx) {
  const { override, forceSplittingGroups, defaultConfig } = ctx;
  return {
    ...defaultConfig,
    minSize: 0,
    maxInitialRequests: Number.POSITIVE_INFINITY,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...forceSplittingGroups,
      // Core group
      vendors: {
        priority: -9,
        test: NODE_MODULES_REGEX,
        name(module2) {
          return module2 ? getPackageNameFromModulePath(module2.context) : void 0;
        }
      },
      ...override.cacheGroups
    }
  };
}
function splitBySize(ctx) {
  const { override, forceSplittingGroups, defaultConfig, userConfig } = ctx;
  (0, import_node_assert.default)(userConfig.strategy === "split-by-size");
  return {
    ...defaultConfig,
    minSize: userConfig.minSize ?? 0,
    maxSize: userConfig.maxSize ?? Number.POSITIVE_INFINITY,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...forceSplittingGroups,
      ...override.cacheGroups
    }
  };
}
function splitCustom(ctx) {
  const { override, forceSplittingGroups, defaultConfig } = ctx;
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...forceSplittingGroups,
      ...override.cacheGroups
    }
  };
}
function allInOne(_ctx) {
  return false;
}
function singleVendor(ctx) {
  const { override, defaultConfig, forceSplittingGroups } = ctx;
  const singleVendorCacheGroup = {
    singleVendor: {
      test: NODE_MODULES_REGEX,
      priority: 0,
      chunks: "all",
      name: "vendor",
      enforce: true
    }
  };
  return {
    ...defaultConfig,
    ...override,
    cacheGroups: {
      ...defaultConfig.cacheGroups,
      ...singleVendorCacheGroup,
      ...forceSplittingGroups,
      ...override.cacheGroups
    }
  };
}
var import_node_assert, MODULE_PATH_REGEX, SPLIT_STRATEGY_DISPATCHER, pluginSplitChunks;
var init_splitChunks = __esm({
  "src/plugins/splitChunks.ts"() {
    "use strict";
    import_node_assert = __toESM(require("assert"));
    init_constants();
    MODULE_PATH_REGEX = /.*[\\/]node_modules[\\/](?!\.pnpm[\\/])(?:(@[^\\/]+)[\\/])?([^\\/]+)/;
    SPLIT_STRATEGY_DISPATCHER = {
      "split-by-experience": splitByExperience,
      "split-by-module": splitByModule,
      "split-by-size": splitBySize,
      custom: splitCustom,
      "all-in-one": allInOne,
      "single-vendor": singleVendor
    };
    pluginSplitChunks = () => ({
      name: "rsbuild:split-chunks",
      setup(api) {
        api.modifyBundlerChain(
          async (chain, { environment, isServer, isWebWorker }) => {
            if (isServer || isWebWorker) {
              chain.optimization.splitChunks(false);
              if (isWebWorker) {
                chain.module.parser.merge({
                  javascript: {
                    dynamicImportMode: "eager"
                  }
                });
              }
              return;
            }
            const { config } = environment;
            const defaultConfig = {
              chunks: config.moduleFederation?.options?.exposes ? (
                // split only `async` chunks for module federation provider app
                // this ensures that remote entries are not affected by chunk splitting
                "async"
              ) : (
                // split both `initial` and `async` chunks for normal app
                "all"
              ),
              cacheGroups: {}
            };
            if (api.context.bundlerType === "webpack") {
              defaultConfig.enforceSizeThreshold = 5e4;
            }
            const { chunkSplit } = config.performance;
            let forceSplittingGroups = {};
            if (chunkSplit.forceSplitting) {
              forceSplittingGroups = getForceSplittingGroups(
                chunkSplit.forceSplitting
              );
            }
            const override = chunkSplit.strategy === "custom" ? chunkSplit.splitChunks ?? chunkSplit.override : chunkSplit.override;
            const splitChunksOptions = await SPLIT_STRATEGY_DISPATCHER[chunkSplit.strategy || "split-by-experience"]({
              defaultConfig,
              override: override || {},
              forceSplittingGroups,
              userConfig: chunkSplit,
              rootPath: api.context.rootPath,
              polyfill: config.output.polyfill
            });
            chain.optimization.splitChunks(splitChunksOptions);
          }
        );
      }
    });
  }
});

// src/plugins/inlineChunk.ts
var inlineChunk_exports = {};
__export(inlineChunk_exports, {
  pluginInlineChunk: () => pluginInlineChunk
});
function updateSourceMappingURL({
  source,
  compilation,
  publicPath,
  type,
  config
}) {
  const { devtool } = compilation.options;
  if (devtool && // If the source map is inlined, we do not need to update the sourceMappingURL
  !devtool.includes("inline") && source.includes("# sourceMappingURL")) {
    const prefix = addTrailingSlash(
      import_node_path31.default.join(publicPath, config.output.distPath[type] || "")
    );
    return source.replace(
      /# sourceMappingURL=/,
      `# sourceMappingURL=${prefix}`
    );
  }
  return source;
}
function matchTests(name, source, tests) {
  return tests.some((test) => {
    if (isFunction(test)) {
      const size = source.length;
      return test({ name, size });
    }
    return test.exec(name);
  });
}
var import_node_path31, import_types, pluginInlineChunk;
var init_inlineChunk = __esm({
  "src/plugins/inlineChunk.ts"() {
    "use strict";
    import_node_path31 = __toESM(require("path"));
    import_types = require("util/types");
    init_constants();
    init_helpers();
    pluginInlineChunk = () => ({
      name: "rsbuild:inline-chunk",
      setup(api) {
        const inlinedAssets = /* @__PURE__ */ new Set();
        const getInlinedScriptTag = (publicPath, tag, compilation, scriptTests, config) => {
          const { assets } = compilation;
          if (!(tag.attrs?.src && typeof tag.attrs.src === "string")) {
            return tag;
          }
          const { src, ...otherAttrs } = tag.attrs;
          const scriptName = publicPath ? src.replace(publicPath, "") : src;
          const asset = assets[scriptName];
          if (asset == null) {
            return tag;
          }
          const source = asset.source().toString();
          const shouldInline = matchTests(scriptName, source, scriptTests);
          if (!shouldInline) {
            return tag;
          }
          const ret = {
            tag: "script",
            children: updateSourceMappingURL({
              source,
              compilation,
              publicPath,
              type: "js",
              config
            }),
            attrs: {
              ...otherAttrs
            }
          };
          inlinedAssets.add(scriptName);
          return ret;
        };
        const getInlinedCSSTag = (publicPath, tag, compilation, styleTests, config) => {
          const { assets } = compilation;
          if (!(tag.attrs?.href && typeof tag.attrs.href === "string")) {
            return tag;
          }
          const linkName = publicPath ? tag.attrs.href.replace(publicPath, "") : tag.attrs.href;
          const asset = assets[linkName];
          if (asset == null) {
            return tag;
          }
          const source = asset.source().toString();
          const shouldInline = matchTests(linkName, source, styleTests);
          if (!shouldInline) {
            return tag;
          }
          const ret = {
            tag: "style",
            children: updateSourceMappingURL({
              source,
              compilation,
              publicPath,
              type: "css",
              config
            })
          };
          inlinedAssets.add(linkName);
          return ret;
        };
        const getInlinedTag = (publicPath, tag, compilation, scriptTests, styleTests, config) => {
          if (tag.tag === "script") {
            return getInlinedScriptTag(
              publicPath,
              tag,
              compilation,
              scriptTests,
              config
            );
          }
          if (tag.tag === "link" && tag.attrs && tag.attrs.rel === "stylesheet") {
            return getInlinedCSSTag(
              publicPath,
              tag,
              compilation,
              styleTests,
              config
            );
          }
          return tag;
        };
        api.processAssets(
          {
            /**
             * Remove marked inline assets in summarize stage,
             * which should be later than the emitting of html-rspack-plugin
             */
            stage: "summarize"
          },
          ({ compiler, compilation }) => {
            if (inlinedAssets.size === 0) {
              return;
            }
            const { devtool } = compiler.options;
            for (const name of inlinedAssets) {
              if (devtool === "hidden-source-map") {
                compilation.deleteAsset(name);
              } else {
                delete compilation.assets[name];
              }
            }
            inlinedAssets.clear();
          }
        );
        api.modifyHTMLTags(
          ({ headTags, bodyTags }, { compiler, compilation, environment }) => {
            const { htmlPaths, config } = environment;
            if (Object.keys(htmlPaths).length === 0) {
              return { headTags, bodyTags };
            }
            const { inlineStyles, inlineScripts } = config.output;
            const scriptTests = [];
            const styleTests = [];
            const isProdMode = environment.config.mode === "production";
            if (inlineScripts) {
              if (inlineScripts === true) {
                isProdMode && scriptTests.push(JS_REGEX);
              } else if ((0, import_types.isRegExp)(inlineScripts) || isFunction(inlineScripts)) {
                isProdMode && scriptTests.push(inlineScripts);
              } else {
                const enable = inlineScripts.enable === "auto" ? isProdMode : inlineScripts.enable;
                if (enable) {
                  scriptTests.push(inlineScripts.test);
                }
              }
            }
            if (inlineStyles) {
              if (inlineStyles === true) {
                isProdMode && styleTests.push(CSS_REGEX);
              } else if ((0, import_types.isRegExp)(inlineStyles) || isFunction(inlineStyles)) {
                isProdMode && styleTests.push(inlineStyles);
              } else {
                const enable = inlineStyles.enable === "auto" ? isProdMode : inlineStyles.enable;
                if (enable) {
                  styleTests.push(inlineStyles.test);
                }
              }
            }
            if (!scriptTests.length && !styleTests.length) {
              return { headTags, bodyTags };
            }
            const publicPath = getPublicPathFromCompiler(compiler);
            const updateTag = (tag) => getInlinedTag(
              publicPath,
              tag,
              compilation,
              scriptTests,
              styleTests,
              environment.config
            );
            return {
              headTags: headTags.map(updateTag),
              bodyTags: bodyTags.map(updateTag)
            };
          }
        );
      }
    });
  }
});

// src/plugins/rsdoctor.ts
var rsdoctor_exports = {};
__export(rsdoctor_exports, {
  pluginRsdoctor: () => pluginRsdoctor
});
var import_picocolors15, pluginRsdoctor;
var init_rsdoctor = __esm({
  "src/plugins/rsdoctor.ts"() {
    "use strict";
    import_picocolors15 = __toESM(require("../compiled/picocolors/index.js"));
    init_logger();
    pluginRsdoctor = () => ({
      name: "rsbuild:rsdoctor",
      setup(api) {
        api.onBeforeCreateCompiler(async ({ bundlerConfigs }) => {
          if (process.env.RSDOCTOR !== "true") {
            return;
          }
          const isRspack = api.context.bundlerType === "rspack";
          const pluginName = isRspack ? "RsdoctorRspackPlugin" : "RsdoctorWebpackPlugin";
          const isRsdoctorPlugin = (plugin) => plugin?.isRsdoctorPlugin === true || plugin?.constructor?.name === pluginName;
          for (const config of bundlerConfigs) {
            const registered = config.plugins?.some(
              (plugin) => isRsdoctorPlugin(plugin)
            );
            if (registered) {
              return;
            }
          }
          const packageName = isRspack ? "@rsdoctor/rspack-plugin" : "@rsdoctor/webpack-plugin";
          let packagePath;
          try {
            packagePath = require.resolve(packageName, {
              paths: [api.context.rootPath]
            });
          } catch (err) {
            import_rslog.logger.warn(
              `\`process.env.RSDOCTOR\` enabled, please install ${import_picocolors15.default.bold(import_picocolors15.default.yellow(packageName))} package.`
            );
            return;
          }
          let module2;
          try {
            module2 = await import(packagePath);
          } catch (err) {
            import_rslog.logger.error(
              `\`process.env.RSDOCTOR\` enabled, but failed to load ${import_picocolors15.default.bold(import_picocolors15.default.yellow(packageName))} module.`
            );
            return;
          }
          if (!module2 || !module2[pluginName]) {
            return;
          }
          for (const config of bundlerConfigs) {
            config.plugins ||= [];
            config.plugins.push(new module2[pluginName]());
          }
          import_rslog.logger.info(`${import_picocolors15.default.bold(import_picocolors15.default.yellow(packageName))} enabled.`);
        });
      }
    });
  }
});

// src/rspack/preload/helpers/extractChunks.ts
function isAsync(chunk) {
  if ("canBeInitial" in chunk) {
    return !chunk.canBeInitial();
  }
  if ("isInitial" in chunk) {
    return !chunk.isInitial();
  }
  return false;
}
function extractChunks({ compilation, includeType }) {
  const chunks = [...compilation.chunks];
  if (includeType === void 0 || includeType === "async-chunks") {
    return chunks.filter(isAsync);
  }
  if (includeType === "initial") {
    return chunks.filter((chunk) => !isAsync(chunk));
  }
  if (includeType === "all-chunks") {
    return chunks;
  }
  if (includeType === "all-assets") {
    const licenseAssets = [...compilation.assetsInfo?.values() || []].map((info) => {
      if (info.related?.license) {
        return info.related.license;
      }
      return false;
    }).filter(Boolean);
    return [
      {
        files: Object.keys(compilation.assets).filter(
          (t) => !licenseAssets.includes(t)
        )
      }
    ];
  }
  return chunks;
}
var init_extractChunks = __esm({
  "src/rspack/preload/helpers/extractChunks.ts"() {
    "use strict";
  }
});

// src/rspack/preload/helpers/determineAsValue.ts
function determineAsValue({
  href,
  file
}) {
  const url2 = new import_node_url4.URL(file || href, "https://example.com");
  const extension = import_node_path32.default.extname(url2.pathname).slice(1);
  if (["css"].includes(extension)) {
    return "style";
  }
  if (IMAGE_EXTENSIONS.includes(extension)) {
    return "image";
  }
  if (VIDEO_EXTENSIONS.includes(extension)) {
    return "video";
  }
  if (AUDIO_EXTENSIONS.includes(extension)) {
    return "audio";
  }
  if (FONT_EXTENSIONS.includes(extension)) {
    return "font";
  }
  if (["vtt"].includes(extension)) {
    return "track";
  }
  return "script";
}
var import_node_path32, import_node_url4;
var init_determineAsValue = __esm({
  "src/rspack/preload/helpers/determineAsValue.ts"() {
    "use strict";
    import_node_path32 = __toESM(require("path"));
    import_node_url4 = require("url");
    init_constants();
  }
});

// src/rspack/preload/helpers/doesChunkBelongToHtml.ts
function recursiveChunkGroup(chunkGroup) {
  const parents = chunkGroup.getParents();
  if (!parents.length) {
    return [chunkGroup.name];
  }
  return parents.flatMap((chunkParent) => recursiveChunkGroup(chunkParent));
}
function recursiveChunkEntryNames(chunk) {
  const isChunkName = (name) => Boolean(name);
  const [...chunkGroups] = chunk.groupsIterable;
  const names = chunkGroups.flatMap((chunkGroup) => recursiveChunkGroup(chunkGroup)).filter(isChunkName);
  return [...new Set(names)];
}
function isChunksFiltered(chunkName, includeChunks, excludeChunks) {
  if (Array.isArray(includeChunks) && includeChunks.indexOf(chunkName) === -1) {
    return false;
  }
  if (Array.isArray(excludeChunks) && excludeChunks.indexOf(chunkName) !== -1) {
    return false;
  }
  return true;
}
function doesChunkBelongToHtml({
  chunk,
  htmlPluginData
}) {
  const { options } = htmlPluginData.plugin;
  const chunkNames = recursiveChunkEntryNames(chunk);
  return chunkNames.some(
    (chunkName) => isChunksFiltered(chunkName, options?.chunks, options?.excludeChunks)
  );
}
var init_doesChunkBelongToHtml = __esm({
  "src/rspack/preload/helpers/doesChunkBelongToHtml.ts"() {
    "use strict";
  }
});

// src/rspack/preload/helpers/type.ts
var init_type2 = __esm({
  "src/rspack/preload/helpers/type.ts"() {
    "use strict";
  }
});

// src/rspack/preload/helpers/index.ts
var init_helpers2 = __esm({
  "src/rspack/preload/helpers/index.ts"() {
    "use strict";
    init_extractChunks();
    init_determineAsValue();
    init_doesChunkBelongToHtml();
    init_type2();
  }
});

// src/rspack/preload/HtmlPreloadOrPrefetchPlugin.ts
var HtmlPreloadOrPrefetchPlugin_exports = {};
__export(HtmlPreloadOrPrefetchPlugin_exports, {
  HtmlPreloadOrPrefetchPlugin: () => HtmlPreloadOrPrefetchPlugin
});
function filterResourceHints(resourceHints, scripts) {
  return resourceHints.filter(
    (resourceHint) => !scripts.find(
      (script) => script.attributes.src === resourceHint.attributes.href
    )
  );
}
function generateLinks(options, type, compilation, htmlPluginData, HTMLCount) {
  const extractedChunks = extractChunks({
    compilation,
    includeType: options.type
  });
  const htmlChunks = (
    // Handle all chunks.
    options.type === "all-assets" || HTMLCount === 1 ? extractedChunks : (
      // Only handle chunks imported by this HtmlRspackPlugin.
      extractedChunks.filter(
        (chunk) => doesChunkBelongToHtml({
          chunk,
          compilation,
          htmlPluginData,
          pluginOptions: options
        })
      )
    )
  );
  const allFiles = htmlChunks.reduce(
    (accumulated, chunk) => accumulated.concat([
      ...chunk.files,
      // sourcemap files are inside auxiliaryFiles in webpack5
      ...chunk.auxiliaryFiles || []
    ]),
    []
  );
  const uniqueFiles = new Set(allFiles);
  const filteredFiles = [...uniqueFiles].filter((file) => [/.map$/].every((regex) => !regex.test(file))).filter(
    (file) => !options.include || (typeof options.include === "function" ? options.include(file) : options.include.some((regex) => new RegExp(regex).test(file)))
  ).filter(
    (file) => !options.exclude || (typeof options.exclude === "function" ? !options.exclude(file) : options.exclude.every((regex) => !new RegExp(regex).test(file)))
  );
  const sortedFilteredFiles = filteredFiles.sort();
  const links = [];
  const { publicPath, crossOriginLoading } = compilation.outputOptions;
  for (const file of sortedFilteredFiles) {
    const href = ensureAssetPrefix(file, publicPath);
    const attributes = {
      href,
      rel: type
    };
    if (type === "preload") {
      attributes.as = determineAsValue({
        href,
        file
      });
      if (attributes.as === "font") {
        attributes.crossorigin = "";
      }
      if (attributes.as === "script" || attributes.as === "style") {
        if (crossOriginLoading && !(crossOriginLoading !== "use-credentials" && publicPath === "/")) {
          attributes.crossorigin = crossOriginLoading === "anonymous" ? "" : crossOriginLoading;
        }
      }
    }
    links.push({
      tagName: "link",
      attributes,
      voidTag: true,
      meta: {}
    });
  }
  return links;
}
var defaultOptions, HtmlPreloadOrPrefetchPlugin;
var init_HtmlPreloadOrPrefetchPlugin = __esm({
  "src/rspack/preload/HtmlPreloadOrPrefetchPlugin.ts"() {
    "use strict";
    init_helpers();
    init_pluginHelper();
    init_helpers2();
    defaultOptions = {
      type: "async-chunks"
    };
    HtmlPreloadOrPrefetchPlugin = class {
      constructor(options, type, HTMLCount) {
        __publicField(this, "options");
        __publicField(this, "resourceHints", []);
        __publicField(this, "type");
        __publicField(this, "HTMLCount");
        this.options = {
          ...defaultOptions,
          ...typeof options === "boolean" ? {} : options
        };
        this.type = type;
        this.HTMLCount = HTMLCount;
      }
      apply(compiler) {
        compiler.hooks.compilation.tap(this.constructor.name, (compilation) => {
          getHTMLPlugin().getHooks(compilation).beforeAssetTagGeneration.tap(
            `HTML${upperFirst(this.type)}Plugin`,
            (htmlPluginData) => {
              this.resourceHints = generateLinks(
                this.options,
                this.type,
                compilation,
                htmlPluginData,
                this.HTMLCount
              );
              return htmlPluginData;
            }
          );
          getHTMLPlugin().getHooks(compilation).alterAssetTags.tap(
            `HTML${upperFirst(this.type)}Plugin`,
            (htmlPluginData) => {
              if (this.resourceHints) {
                htmlPluginData.assetTags.styles = [
                  ...filterResourceHints(
                    this.resourceHints,
                    htmlPluginData.assetTags.scripts
                  ),
                  ...htmlPluginData.assetTags.styles
                ];
              }
              return htmlPluginData;
            }
          );
        });
      }
    };
  }
});

// src/plugins/resourceHints.ts
var resourceHints_exports = {};
__export(resourceHints_exports, {
  pluginResourceHints: () => pluginResourceHints
});
var generateLinks2, pluginResourceHints;
var init_resourceHints = __esm({
  "src/plugins/resourceHints.ts"() {
    "use strict";
    generateLinks2 = (options, rel) => options.map((option) => ({
      tag: "link",
      attrs: {
        rel,
        ...option
      }
    }));
    pluginResourceHints = () => ({
      name: "rsbuild:resource-hints",
      setup(api) {
        api.modifyHTMLTags(({ headTags, bodyTags }, { environment }) => {
          const { config } = environment;
          const { dnsPrefetch, preconnect } = config.performance;
          if (dnsPrefetch) {
            const attrs = dnsPrefetch.map((option) => ({ href: option }));
            if (attrs.length) {
              headTags.unshift(...generateLinks2(attrs, "dns-prefetch"));
            }
          }
          if (preconnect) {
            const attrs = preconnect.map(
              (option) => typeof option === "string" ? { href: option } : option
            );
            if (attrs.length) {
              headTags.unshift(...generateLinks2(attrs, "preconnect"));
            }
          }
          return { headTags, bodyTags };
        });
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
          const { config, htmlPaths } = environment;
          if (Object.keys(htmlPaths).length === 0) {
            return;
          }
          const {
            performance: { preload, prefetch }
          } = config;
          const HTMLCount = chain.entryPoints.values().length;
          const { HtmlPreloadOrPrefetchPlugin: HtmlPreloadOrPrefetchPlugin2 } = await Promise.resolve().then(() => (init_HtmlPreloadOrPrefetchPlugin(), HtmlPreloadOrPrefetchPlugin_exports));
          if (prefetch) {
            chain.plugin(CHAIN_ID2.PLUGIN.HTML_PREFETCH).use(HtmlPreloadOrPrefetchPlugin2, [prefetch, "prefetch", HTMLCount]);
          }
          if (preload) {
            chain.plugin(CHAIN_ID2.PLUGIN.HTML_PRELOAD).use(HtmlPreloadOrPrefetchPlugin2, [preload, "preload", HTMLCount]);
          }
        });
      }
    });
  }
});

// src/plugins/performance.ts
var performance_exports = {};
__export(performance_exports, {
  pluginPerformance: () => pluginPerformance
});
var pluginPerformance;
var init_performance = __esm({
  "src/plugins/performance.ts"() {
    "use strict";
    pluginPerformance = () => ({
      name: "rsbuild:performance",
      setup(api) {
        api.modifyRsbuildConfig({
          order: "post",
          handler: (rsbuildConfig) => {
            const applyBundleAnalyzeConfig = (config) => {
              if (!config.performance?.bundleAnalyze) {
                config.performance ??= {};
                config.performance.bundleAnalyze = {
                  analyzerMode: "disabled",
                  generateStatsFile: true
                };
              } else {
                config.performance.bundleAnalyze = {
                  generateStatsFile: true,
                  ...config.performance.bundleAnalyze || {}
                };
              }
            };
            if (rsbuildConfig.performance?.profile) {
              applyBundleAnalyzeConfig(rsbuildConfig);
            } else if (rsbuildConfig.environments) {
              for (const config of Object.values(rsbuildConfig.environments)) {
                if (config.performance?.profile) {
                  applyBundleAnalyzeConfig(config);
                }
              }
            }
          }
        });
        api.modifyBundlerChain((chain, { environment }) => {
          const { config } = environment;
          const { profile } = config.performance;
          if (!profile) {
            return;
          }
          chain.profile(profile);
        });
      }
    });
  }
});

// src/plugins/bundleAnalyzer.ts
var bundleAnalyzer_exports = {};
__export(bundleAnalyzer_exports, {
  pluginBundleAnalyzer: () => pluginBundleAnalyzer
});
function pluginBundleAnalyzer() {
  return {
    name: "rsbuild:bundle-analyzer",
    setup(api) {
      api.modifyRsbuildConfig({
        order: "post",
        handler: (config) => {
          const useAnalyzer = isUseAnalyzer(config) || Object.values(config.environments || []).some(
            (config2) => isUseAnalyzer(config2)
          );
          if (!useAnalyzer) {
            return;
          }
          config.dev ||= {};
          config.dev.writeToDisk = true;
          return config;
        }
      });
      api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
        const { config } = environment;
        if (!isUseAnalyzer(config)) {
          return;
        }
        const { default: BundleAnalyzer } = await import("../compiled/webpack-bundle-analyzer/index.js");
        chain.plugin(CHAIN_ID2.PLUGIN.BUNDLE_ANALYZER).use(BundleAnalyzer.BundleAnalyzerPlugin, [
          {
            analyzerMode: "static",
            openAnalyzer: false,
            reportFilename: `report-${environment.name}.html`,
            ...config.performance.bundleAnalyze || {}
          }
        ]);
      });
    }
  };
}
var isUseAnalyzer;
var init_bundleAnalyzer = __esm({
  "src/plugins/bundleAnalyzer.ts"() {
    "use strict";
    isUseAnalyzer = (config) => process.env.BUNDLE_ANALYZE || config.performance?.bundleAnalyze;
  }
});

// src/plugins/server.ts
var server_exports = {};
__export(server_exports, {
  pluginServer: () => pluginServer
});
var import_node_fs9, import_node_path33, pluginServer;
var init_server = __esm({
  "src/plugins/server.ts"() {
    "use strict";
    import_node_fs9 = __toESM(require("fs"));
    import_node_path33 = require("path");
    init_config();
    pluginServer = () => ({
      name: "rsbuild:server",
      setup(api) {
        api.onBeforeBuild(async ({ isFirstCompile }) => {
          if (!isFirstCompile) {
            return;
          }
          const config = api.getNormalizedConfig();
          const publicDirs = normalizePublicDirs(config.server.publicDir);
          for (const publicDir of publicDirs) {
            const { name, copyOnBuild } = publicDir;
            if (!copyOnBuild || !name) {
              continue;
            }
            const normalizedPath = (0, import_node_path33.isAbsolute)(name) ? name : (0, import_node_path33.join)(api.context.rootPath, name);
            if (!import_node_fs9.default.existsSync(normalizedPath)) {
              continue;
            }
            try {
              await import_node_fs9.default.promises.cp(normalizedPath, api.context.distPath, {
                recursive: true,
                // dereference symlinks
                dereference: true
              });
            } catch (err) {
              if (err instanceof Error) {
                err.message = `Copy public dir (${normalizedPath}) to dist failed:
${err.message}`;
              }
              throw err;
            }
          }
        });
      }
    });
  }
});

// src/plugins/manifest.ts
var manifest_exports = {};
__export(manifest_exports, {
  pluginManifest: () => pluginManifest
});
var generateManifest, pluginManifest;
var init_manifest = __esm({
  "src/plugins/manifest.ts"() {
    "use strict";
    init_helpers2();
    generateManifest = (htmlPaths) => (_seed, files) => {
      const chunkEntries = /* @__PURE__ */ new Map();
      const licenseMap = /* @__PURE__ */ new Map();
      const allFiles = files.map((file) => {
        if (file.chunk) {
          const names = recursiveChunkEntryNames(file.chunk);
          for (const name of names) {
            chunkEntries.set(name, [file, ...chunkEntries.get(name) || []]);
          }
        }
        if (file.path.endsWith(".LICENSE.txt")) {
          const sourceFilePath = file.path.split(".LICENSE.txt")[0];
          licenseMap.set(sourceFilePath, file.path);
        }
        return file.path;
      });
      const entries = {};
      for (const [name, chunkFiles] of chunkEntries) {
        const assets = /* @__PURE__ */ new Set();
        const initialJS = [];
        const asyncJS = [];
        const initialCSS = [];
        const asyncCSS = [];
        for (const file of chunkFiles) {
          if (file.isInitial) {
            if (file.path.endsWith(".css")) {
              initialCSS.push(file.path);
            } else {
              initialJS.push(file.path);
            }
          } else {
            if (file.path.endsWith(".css")) {
              asyncCSS.push(file.path);
            } else {
              asyncJS.push(file.path);
            }
          }
          const relatedLICENSE = licenseMap.get(file.path);
          if (relatedLICENSE) {
            assets.add(relatedLICENSE);
          }
          for (const auxiliaryFile of file.chunk.auxiliaryFiles) {
            assets.add(auxiliaryFile);
          }
        }
        const entryManifest = {};
        if (assets.size) {
          entryManifest.assets = Array.from(assets);
        }
        const htmlPath = files.find((f) => f.name === htmlPaths[name])?.path;
        if (htmlPath) {
          entryManifest.html = [htmlPath];
        }
        if (initialJS.length) {
          entryManifest.initial = {
            js: initialJS
          };
        }
        if (initialCSS.length) {
          entryManifest.initial = {
            ...entryManifest.initial || {},
            css: initialCSS
          };
        }
        if (asyncJS.length) {
          entryManifest.async = {
            js: asyncJS
          };
        }
        if (asyncCSS.length) {
          entryManifest.async = {
            ...entryManifest.async || {},
            css: asyncCSS
          };
        }
        entries[name] = entryManifest;
      }
      return {
        allFiles,
        entries
      };
    };
    pluginManifest = () => ({
      name: "rsbuild:manifest",
      setup(api) {
        api.modifyBundlerChain(async (chain, { CHAIN_ID: CHAIN_ID2, environment }) => {
          const {
            output: { manifest }
          } = environment.config;
          if (manifest === false) {
            return;
          }
          const fileName = typeof manifest === "string" ? manifest : "manifest.json";
          const { RspackManifestPlugin } = await import("../compiled/rspack-manifest-plugin/index.js");
          const { htmlPaths } = environment;
          chain.plugin(CHAIN_ID2.PLUGIN.MANIFEST).use(RspackManifestPlugin, [
            {
              fileName,
              generate: generateManifest(htmlPaths)
            }
          ]);
        });
      }
    });
  }
});

// src/plugins/moduleFederation.ts
var moduleFederation_exports = {};
__export(moduleFederation_exports, {
  pluginModuleFederation: () => pluginModuleFederation
});
function pluginModuleFederation() {
  return {
    name: "rsbuild:module-federation",
    setup(api) {
      api.modifyRsbuildConfig((config) => {
        const { moduleFederation } = config;
        if (!moduleFederation?.options) {
          return;
        }
        if (moduleFederation.options.exposes && config.server?.port && !config.dev?.client?.port) {
          config.dev ||= {};
          config.dev.client ||= {};
          config.dev.client.port = config.server.port;
        }
      });
      api.modifyEnvironmentConfig((config) => {
        if (!config.moduleFederation?.options) {
          return;
        }
        if (config.performance?.chunkSplit?.strategy === "split-by-experience") {
          config.performance.chunkSplit = {
            ...config.performance.chunkSplit,
            strategy: "custom"
          };
        }
        config.source.include = [
          ...config.source.include || [],
          /@module-federation[\\/]sdk/,
          /@module-federation[\\/]runtime/
        ];
      });
      api.modifyBundlerChain(
        async (chain, { CHAIN_ID: CHAIN_ID2, target, environment }) => {
          const { config } = environment;
          if (!config.moduleFederation?.options || target !== "web") {
            return;
          }
          const { options } = config.moduleFederation;
          chain.plugin(CHAIN_ID2.PLUGIN.MODULE_FEDERATION).use(import_core8.rspack.container.ModuleFederationPlugin, [options]);
          if (options.name) {
            if (options.exposes) {
              chain.plugin("mf-patch-split-chunks").use(PatchSplitChunksPlugin, [options.name]);
            }
            if (!chain.output.get("uniqueName")) {
              chain.output.set("uniqueName", options.name);
            }
          }
          const publicPath = chain.output.get("publicPath");
          if (publicPath === DEFAULT_ASSET_PREFIX) {
            chain.output.set("publicPath", "auto");
          }
        }
      );
    }
  };
}
var import_types2, import_core8, PatchSplitChunksPlugin;
var init_moduleFederation = __esm({
  "src/plugins/moduleFederation.ts"() {
    "use strict";
    import_types2 = require("util/types");
    import_core8 = require("@rspack/core");
    init_constants();
    PatchSplitChunksPlugin = class {
      constructor(name) {
        __publicField(this, "name");
        this.name = name;
      }
      apply(compiler) {
        const { splitChunks } = compiler.options.optimization;
        if (!splitChunks) {
          return;
        }
        const applyPatch = (cacheGroup) => {
          if (typeof cacheGroup !== "object" || (0, import_types2.isRegExp)(cacheGroup)) {
            return;
          }
          const { chunks } = cacheGroup;
          if (!chunks || chunks === "async") {
            return;
          }
          if (typeof chunks === "function") {
            const prevChunks = chunks;
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return prevChunks(chunk);
            };
            return;
          }
          if (chunks === "all") {
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return true;
            };
            return;
          }
          if (chunks === "initial") {
            cacheGroup.chunks = (chunk) => {
              if (chunk.name && chunk.name === this.name) {
                return false;
              }
              return chunk.isOnlyInitial();
            };
            return;
          }
        };
        applyPatch(splitChunks);
        const { cacheGroups } = splitChunks;
        if (!cacheGroups) {
          return;
        }
        for (const cacheGroupKey of Object.keys(cacheGroups)) {
          applyPatch(cacheGroups[cacheGroupKey]);
        }
      }
    };
  }
});

// src/plugins/rspackProfile.ts
var rspackProfile_exports = {};
__export(rspackProfile_exports, {
  pluginRspackProfile: () => pluginRspackProfile
});
var import_node_fs10, import_node_inspector, import_node_path34, import_core9, stopProfiler, pluginRspackProfile;
var init_rspackProfile = __esm({
  "src/plugins/rspackProfile.ts"() {
    "use strict";
    import_node_fs10 = __toESM(require("fs"));
    import_node_inspector = __toESM(require("inspector"));
    import_node_path34 = __toESM(require("path"));
    import_core9 = __toESM(require("@rspack/core"));
    init_logger();
    stopProfiler = (output, profileSession) => {
      if (!profileSession) {
        return;
      }
      profileSession.post("Profiler.stop", (error, param) => {
        if (error) {
          import_rslog.logger.error("Failed to generate JS CPU profile:", error);
          return;
        }
        import_node_fs10.default.writeFileSync(output, JSON.stringify(param.profile));
      });
    };
    pluginRspackProfile = () => ({
      name: "rsbuild:rspack-profile",
      async setup(api) {
        if (api.context.bundlerType === "webpack") {
          return;
        }
        const RSPACK_PROFILE = process.env.RSPACK_PROFILE?.toUpperCase();
        if (!RSPACK_PROFILE) {
          return;
        }
        const timestamp = Date.now();
        const profileDirName = `rspack-profile-${timestamp}`;
        let profileSession;
        const enableProfileTrace = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("TRACE");
        const enableCPUProfile = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("CPU");
        const enableLogging = RSPACK_PROFILE === "ALL" || RSPACK_PROFILE.includes("LOGGING");
        const onStart = () => {
          const profileDir = import_node_path34.default.join(api.context.distPath, profileDirName);
          const traceFilePath = import_node_path34.default.join(profileDir, "trace.json");
          if (!import_node_fs10.default.existsSync(profileDir)) {
            import_node_fs10.default.mkdirSync(profileDir, { recursive: true });
          }
          if (enableProfileTrace) {
            import_core9.default.experiments.globalTrace.register(
              "trace",
              "chrome",
              traceFilePath
            );
          }
          if (enableCPUProfile) {
            profileSession = new import_node_inspector.default.Session();
            profileSession.connect();
            profileSession.post("Profiler.enable");
            profileSession.post("Profiler.start");
          }
        };
        api.onBeforeBuild(({ isFirstCompile }) => {
          if (isFirstCompile) {
            onStart();
          }
        });
        api.onBeforeStartDevServer(onStart);
        api.onAfterBuild(async ({ stats }) => {
          const loggingFilePath = import_node_path34.default.join(
            api.context.distPath,
            profileDirName,
            "logging.json"
          );
          if (enableLogging && stats) {
            const logging = stats.toJson({
              all: false,
              logging: "verbose",
              loggingTrace: true
            });
            import_node_fs10.default.writeFileSync(loggingFilePath, JSON.stringify(logging));
          }
        });
        api.onExit(() => {
          if (enableProfileTrace) {
            import_core9.default.experiments.globalTrace.cleanup();
          }
          const profileDir = import_node_path34.default.join(api.context.distPath, profileDirName);
          const cpuProfilePath = import_node_path34.default.join(profileDir, "jscpuprofile.json");
          stopProfiler(cpuProfilePath, profileSession);
          import_rslog.logger.info(`Saved Rspack profile file to ${profileDir}`);
        });
      }
    });
  }
});

// src/plugins/lazyCompilation.ts
var lazyCompilation_exports = {};
__export(lazyCompilation_exports, {
  pluginLazyCompilation: () => pluginLazyCompilation
});
var pluginLazyCompilation;
var init_lazyCompilation = __esm({
  "src/plugins/lazyCompilation.ts"() {
    "use strict";
    pluginLazyCompilation = () => ({
      name: "rsbuild:lazy-compilation",
      setup(api) {
        api.modifyBundlerChain((chain, { environment, isProd, target }) => {
          if (isProd || target !== "web") {
            return;
          }
          const { config } = environment;
          const options = config.dev?.lazyCompilation;
          if (!options) {
            return;
          }
          chain.experiments({
            ...chain.get("experiments"),
            lazyCompilation: options
          });
        });
      }
    });
  }
});

// src/plugins/sri.ts
var sri_exports = {};
__export(sri_exports, {
  pluginSri: () => pluginSri
});
var import_node_crypto2, getAssetName, pluginSri;
var init_sri = __esm({
  "src/plugins/sri.ts"() {
    "use strict";
    import_node_crypto2 = __toESM(require("crypto"));
    init_constants();
    init_helpers();
    init_logger();
    getAssetName = (url2, assetPrefix) => {
      if (url2.startsWith(assetPrefix)) {
        return removeLeadingSlash(url2.replace(assetPrefix, ""));
      }
      return removeLeadingSlash(url2);
    };
    pluginSri = () => ({
      name: "rsbuild:sri",
      setup(api) {
        const placeholder = "RSBUILD_INTEGRITY_PLACEHOLDER:";
        const getAlgorithm = (environment) => {
          const { config } = environment;
          const { sri } = config.security;
          const enable = sri.enable === "auto" ? config.mode === "production" : sri.enable;
          if (!enable) {
            return null;
          }
          const { algorithm = "sha384" } = sri;
          return algorithm;
        };
        api.modifyHTMLTags({
          // ensure `sri` can be applied to all tags
          order: "post",
          handler(tags, { assetPrefix, environment }) {
            const algorithm = getAlgorithm(environment);
            if (!algorithm) {
              return tags;
            }
            const allTags = [...tags.headTags, ...tags.bodyTags];
            for (const tag of allTags) {
              let url2 = "";
              if (!tag.attrs) {
                continue;
              }
              if (tag.tag === "script" && typeof tag.attrs.src === "string") {
                url2 = tag.attrs.src;
              } else if (tag.tag === "link" && tag.attrs.rel === "stylesheet" && typeof tag.attrs.href === "string") {
                url2 = tag.attrs.href;
              }
              if (!url2) {
                continue;
              }
              const assetName = getAssetName(url2, assetPrefix);
              if (!assetName) {
                continue;
              }
              tag.attrs.integrity ??= `${placeholder}${assetName}`;
            }
            return tags;
          }
        });
        const replaceIntegrity = (htmlContent, assets, algorithm, integrityCache) => {
          const regex = /integrity="RSBUILD_INTEGRITY_PLACEHOLDER:([^"]+)"/g;
          const matches = htmlContent.matchAll(regex);
          let replacedHtml = htmlContent;
          const calcIntegrity = (algorithm2, assetName, data) => {
            if (integrityCache.has(assetName)) {
              return integrityCache.get(assetName);
            }
            const hash = import_node_crypto2.default.createHash(algorithm2).update(data).digest().toString("base64");
            const integrity = `${algorithm2}-${hash}`;
            integrityCache.set(assetName, integrity);
            return integrity;
          };
          for (const match of matches) {
            const assetName = match[1];
            if (!assetName) {
              continue;
            }
            if (assets[assetName]) {
              const integrity = calcIntegrity(
                algorithm,
                assetName,
                assets[assetName].buffer()
              );
              replacedHtml = replacedHtml.replaceAll(
                `integrity="${placeholder}${assetName}"`,
                `integrity="${integrity}"`
              );
            } else {
              import_rslog.logger.debug(
                `[rsbuild:sri] failed to generate integrity for ${assetName}.`
              );
              replacedHtml = replacedHtml.replace(
                `integrity="${placeholder}${assetName}"`,
                ""
              );
            }
          }
          return replacedHtml;
        };
        api.processAssets(
          {
            // use to final stage to get the final asset content
            stage: "report"
          },
          ({ assets, sources, environment }) => {
            const { htmlPaths } = environment;
            if (Object.keys(htmlPaths).length === 0) {
              return;
            }
            const algorithm = getAlgorithm(environment);
            if (!algorithm) {
              return;
            }
            const integrityCache = /* @__PURE__ */ new Map();
            for (const asset of Object.keys(assets)) {
              if (!HTML_REGEX.test(asset)) {
                continue;
              }
              const htmlContent = assets[asset].source();
              if (!htmlContent.includes(placeholder)) {
                continue;
              }
              assets[asset] = new sources.RawSource(
                replaceIntegrity(htmlContent, assets, algorithm, integrityCache)
              );
            }
          }
        );
      }
    });
  }
});

// src/plugins/nonce.ts
var nonce_exports = {};
__export(nonce_exports, {
  pluginNonce: () => pluginNonce
});
var pluginNonce;
var init_nonce = __esm({
  "src/plugins/nonce.ts"() {
    "use strict";
    init_helpers();
    pluginNonce = () => ({
      name: "rsbuild:nonce",
      setup(api) {
        api.onAfterCreateCompiler(({ compiler, environments }) => {
          const nonces = Object.values(environments).map((environment) => {
            const { nonce } = environment.config.security;
            return nonce;
          });
          if (!nonces.some((nonce) => !!nonce)) {
            return;
          }
          const environmentList = Object.values(environments);
          applyToCompiler(compiler, (compiler2, index) => {
            const nonce = nonces[index];
            const environment = environmentList.find(
              (item) => item.index === index
            );
            const hasHTML = Object.keys(environment?.htmlPaths ?? {}).length;
            if (!hasHTML || !nonce) {
              return;
            }
            const injectCode = createVirtualModule(
              `__webpack_nonce__ = "${nonce}";`
            );
            new compiler2.webpack.EntryPlugin(compiler2.context, injectCode, {
              name: void 0
            }).apply(compiler2);
          });
        });
        api.modifyHTMLTags({
          // ensure `nonce` can be applied to all tags
          order: "post",
          handler: ({ headTags, bodyTags }, { environment }) => {
            const { config } = environment;
            const { nonce } = config.security;
            const allTags = [...headTags, ...bodyTags];
            if (nonce) {
              for (const tag of allTags) {
                if (tag.tag === "script" || tag.tag === "style") {
                  tag.attrs ??= {};
                  tag.attrs.nonce = nonce;
                }
              }
            }
            return { headTags, bodyTags };
          }
        });
      }
    });
  }
});

// src/server/prodServer.ts
var prodServer_exports = {};
__export(prodServer_exports, {
  RsbuildProdServer: () => RsbuildProdServer,
  startProdServer: () => startProdServer
});
async function startProdServer(context, config, { getPortSilently } = {}) {
  const { port, host, https } = await getServerConfig({
    config,
    getPortSilently
  });
  const { default: connect } = await import("../compiled/connect/index.js");
  const middlewares = connect();
  const serverConfig = config.server;
  const server = new RsbuildProdServer(
    {
      pwd: context.rootPath,
      output: {
        path: context.distPath,
        assetPrefixes: Object.values(context.environments).map(
          (e) => pathnameParse(e.config.output.assetPrefix)
        )
      },
      serverConfig
    },
    middlewares
  );
  await context.hooks.onBeforeStartProdServer.call();
  const httpServer = await createHttpServer({
    serverConfig,
    middlewares: server.middlewares
  });
  const serverTerminator = getServerTerminator(httpServer);
  await server.onInit(httpServer);
  return new Promise((resolve2) => {
    httpServer.listen(
      {
        host,
        port
      },
      async () => {
        const routes = getRoutes(context);
        await context.hooks.onAfterStartProdServer.call({
          port,
          routes,
          environments: context.environments
        });
        const protocol = https ? "https" : "http";
        const urls = getAddressUrls({ protocol, port, host });
        printServerURLs({
          urls,
          port,
          routes,
          protocol,
          printUrls: serverConfig.printUrls
        });
        const onClose = async () => {
          await Promise.all([server.close(), serverTerminator()]);
        };
        resolve2({
          port,
          urls: urls.map((item) => item.url),
          server: {
            close: onClose
          }
        });
      }
    );
  });
}
var RsbuildProdServer;
var init_prodServer = __esm({
  "src/server/prodServer.ts"() {
    "use strict";
    init_path();
    init_logger();
    init_helper();
    init_httpServer();
    init_middlewares();
    RsbuildProdServer = class {
      constructor(options, middlewares) {
        __publicField(this, "app");
        __publicField(this, "options");
        __publicField(this, "middlewares");
        this.options = options;
        this.middlewares = middlewares;
      }
      // Complete the preparation of services
      async onInit(app) {
        this.app = app;
        await this.applyDefaultMiddlewares();
      }
      async applyDefaultMiddlewares() {
        const { headers, proxy, historyApiFallback, compress } = this.options.serverConfig;
        if (import_rslog.logger.level === "verbose") {
          this.middlewares.use(await getRequestLoggerMiddleware());
        }
        if (compress) {
          const { gzipMiddleware: gzipMiddleware2 } = await Promise.resolve().then(() => (init_gzipMiddleware(), gzipMiddleware_exports));
          this.middlewares.use(
            gzipMiddleware2({
              // simulates the common gzip compression rates
              level: 6
            })
          );
        }
        if (headers) {
          this.middlewares.use((_req, res, next) => {
            for (const [key, value] of Object.entries(headers)) {
              res.setHeader(key, value);
            }
            next();
          });
        }
        if (proxy) {
          const { createProxyMiddleware: createProxyMiddleware2 } = await Promise.resolve().then(() => (init_proxy(), proxy_exports));
          const { middlewares, upgrade } = await createProxyMiddleware2(proxy);
          for (const middleware of middlewares) {
            this.middlewares.use(middleware);
          }
          this.app.on("upgrade", upgrade);
        }
        this.applyStaticAssetMiddleware();
        if (historyApiFallback) {
          const { default: connectHistoryApiFallback } = await import("../compiled/connect-history-api-fallback/index.js");
          const historyApiFallbackMiddleware = connectHistoryApiFallback(
            historyApiFallback === true ? {} : historyApiFallback
          );
          this.middlewares.use(historyApiFallbackMiddleware);
          await this.applyStaticAssetMiddleware();
        }
        this.middlewares.use(faviconFallbackMiddleware);
      }
      async applyStaticAssetMiddleware() {
        const {
          output: { path: path20, assetPrefixes },
          serverConfig: { htmlFallback }
        } = this.options;
        const { default: sirv } = await import("../compiled/sirv/index.js");
        const assetMiddleware = sirv(path20, {
          etag: true,
          dev: true,
          ignores: ["favicon.ico"],
          single: htmlFallback === "index"
        });
        this.middlewares.use((req, res, next) => {
          const url2 = req.url;
          const assetPrefix = url2 && assetPrefixes.find((prefix) => url2.startsWith(prefix));
          if (assetPrefix && url2?.startsWith(assetPrefix)) {
            req.url = url2.slice(assetPrefix.length);
            assetMiddleware(req, res, (...args) => {
              req.url = url2;
              next(...args);
            });
          } else {
            assetMiddleware(req, res, next);
          }
        });
      }
      async close() {
      }
    };
  }
});

// src/createRsbuild.ts
var createRsbuild_exports = {};
__export(createRsbuild_exports, {
  createRsbuild: () => createRsbuild
});
async function applyDefaultPlugins(pluginManager, context) {
  const plugins = await Promise.all([
    Promise.resolve().then(() => (init_basic2(), basic_exports)).then(({ pluginBasic: pluginBasic2 }) => pluginBasic2()),
    Promise.resolve().then(() => (init_entry(), entry_exports)).then(({ pluginEntry: pluginEntry2 }) => pluginEntry2()),
    Promise.resolve().then(() => (init_cache(), cache_exports)).then(({ pluginCache: pluginCache2 }) => pluginCache2()),
    Promise.resolve().then(() => (init_target(), target_exports)).then(({ pluginTarget: pluginTarget2 }) => pluginTarget2()),
    Promise.resolve().then(() => (init_output(), output_exports)).then(({ pluginOutput: pluginOutput2 }) => pluginOutput2()),
    Promise.resolve().then(() => (init_resolve(), resolve_exports)).then(({ pluginResolve: pluginResolve2 }) => pluginResolve2()),
    Promise.resolve().then(() => (init_fileSize(), fileSize_exports)).then(({ pluginFileSize: pluginFileSize2 }) => pluginFileSize2()),
    // cleanOutput plugin should before the html plugin
    Promise.resolve().then(() => (init_cleanOutput(), cleanOutput_exports)).then(
      ({ pluginCleanOutput: pluginCleanOutput2 }) => pluginCleanOutput2()
    ),
    Promise.resolve().then(() => (init_asset(), asset_exports)).then(({ pluginAsset: pluginAsset2 }) => pluginAsset2()),
    Promise.resolve().then(() => (init_html(), html_exports)).then(
      ({ pluginHtml: pluginHtml2 }) => pluginHtml2((environment) => async (...args) => {
        const result = await context.hooks.modifyHTMLTags.callInEnvironment({
          environment,
          args
        });
        return result[0];
      })
    ),
    Promise.resolve().then(() => (init_appIcon(), appIcon_exports)).then(({ pluginAppIcon: pluginAppIcon2 }) => pluginAppIcon2()),
    Promise.resolve().then(() => (init_wasm(), wasm_exports)).then(({ pluginWasm: pluginWasm2 }) => pluginWasm2()),
    Promise.resolve().then(() => (init_moment(), moment_exports)).then(({ pluginMoment: pluginMoment2 }) => pluginMoment2()),
    Promise.resolve().then(() => (init_nodeAddons(), nodeAddons_exports)).then(
      ({ pluginNodeAddons: pluginNodeAddons2 }) => pluginNodeAddons2()
    ),
    Promise.resolve().then(() => (init_define(), define_exports)).then(({ pluginDefine: pluginDefine2 }) => pluginDefine2()),
    Promise.resolve().then(() => (init_css(), css_exports)).then(({ pluginCss: pluginCss2 }) => pluginCss2()),
    Promise.resolve().then(() => (init_minimize(), minimize_exports)).then(({ pluginMinimize: pluginMinimize2 }) => pluginMinimize2()),
    Promise.resolve().then(() => (init_progress(), progress_exports)).then(({ pluginProgress: pluginProgress2 }) => pluginProgress2()),
    Promise.resolve().then(() => (init_swc(), swc_exports)).then(({ pluginSwc: pluginSwc2 }) => pluginSwc2()),
    Promise.resolve().then(() => (init_externals(), externals_exports)).then(
      ({ pluginExternals: pluginExternals2 }) => pluginExternals2()
    ),
    Promise.resolve().then(() => (init_splitChunks(), splitChunks_exports)).then(
      ({ pluginSplitChunks: pluginSplitChunks2 }) => pluginSplitChunks2()
    ),
    Promise.resolve().then(() => (init_open(), open_exports)).then(({ pluginOpen: pluginOpen2 }) => pluginOpen2()),
    Promise.resolve().then(() => (init_inlineChunk(), inlineChunk_exports)).then(
      ({ pluginInlineChunk: pluginInlineChunk2 }) => pluginInlineChunk2()
    ),
    Promise.resolve().then(() => (init_rsdoctor(), rsdoctor_exports)).then(({ pluginRsdoctor: pluginRsdoctor2 }) => pluginRsdoctor2()),
    Promise.resolve().then(() => (init_resourceHints(), resourceHints_exports)).then(
      ({ pluginResourceHints: pluginResourceHints2 }) => pluginResourceHints2()
    ),
    Promise.resolve().then(() => (init_performance(), performance_exports)).then(
      ({ pluginPerformance: pluginPerformance2 }) => pluginPerformance2()
    ),
    Promise.resolve().then(() => (init_bundleAnalyzer(), bundleAnalyzer_exports)).then(
      ({ pluginBundleAnalyzer: pluginBundleAnalyzer2 }) => pluginBundleAnalyzer2()
    ),
    Promise.resolve().then(() => (init_server(), server_exports)).then(({ pluginServer: pluginServer2 }) => pluginServer2()),
    Promise.resolve().then(() => (init_manifest(), manifest_exports)).then(({ pluginManifest: pluginManifest2 }) => pluginManifest2()),
    Promise.resolve().then(() => (init_moduleFederation(), moduleFederation_exports)).then(
      ({ pluginModuleFederation: pluginModuleFederation2 }) => pluginModuleFederation2()
    ),
    Promise.resolve().then(() => (init_rspackProfile(), rspackProfile_exports)).then(
      ({ pluginRspackProfile: pluginRspackProfile2 }) => pluginRspackProfile2()
    ),
    Promise.resolve().then(() => (init_lazyCompilation(), lazyCompilation_exports)).then(
      ({ pluginLazyCompilation: pluginLazyCompilation2 }) => pluginLazyCompilation2()
    ),
    Promise.resolve().then(() => (init_sri(), sri_exports)).then(({ pluginSri: pluginSri2 }) => pluginSri2()),
    Promise.resolve().then(() => (init_nonce(), nonce_exports)).then(({ pluginNonce: pluginNonce2 }) => pluginNonce2())
  ]);
  pluginManager.addPlugins(plugins);
}
async function createRsbuild(options = {}) {
  const { rsbuildConfig = {} } = options;
  const rsbuildOptions = {
    cwd: process.cwd(),
    rsbuildConfig,
    ...options
  };
  const pluginManager = createPluginManager();
  const context = await createContext(
    rsbuildOptions,
    rsbuildOptions.rsbuildConfig,
    rsbuildConfig.provider ? "webpack" : "rspack"
  );
  const getPluginAPI = initPluginAPI({ context, pluginManager });
  context.getPluginAPI = getPluginAPI;
  const globalPluginAPI = getPluginAPI();
  import_rslog.logger.debug("add default plugins");
  await applyDefaultPlugins(pluginManager, context);
  import_rslog.logger.debug("add default plugins done");
  const provider = rsbuildConfig.provider || await getRspackProvider();
  const providerInstance = await provider({
    context,
    pluginManager,
    rsbuildOptions,
    setCssExtractPlugin
  });
  const preview = async (options2) => {
    if (!getNodeEnv()) {
      setNodeEnv("production");
    }
    const { startProdServer: startProdServer2 } = await Promise.resolve().then(() => (init_prodServer(), prodServer_exports));
    const config = await initRsbuildConfig({ context, pluginManager });
    return startProdServer2(context, config, options2);
  };
  const build2 = (...args) => {
    if (!getNodeEnv()) {
      setNodeEnv("production");
    }
    return providerInstance.build(...args);
  };
  const startDevServer = (...args) => {
    if (!getNodeEnv()) {
      setNodeEnv("development");
    }
    return providerInstance.startDevServer(...args);
  };
  const createDevServer2 = (...args) => {
    if (!getNodeEnv()) {
      setNodeEnv("development");
    }
    return providerInstance.createDevServer(...args);
  };
  const rsbuild = {
    build: build2,
    preview,
    startDevServer,
    createDevServer: createDevServer2,
    ...pick(pluginManager, [
      "addPlugins",
      "getPlugins",
      "removePlugins",
      "isPluginExists"
    ]),
    ...pick(globalPluginAPI, [
      "context",
      "onBeforeBuild",
      "onBeforeCreateCompiler",
      "onBeforeStartDevServer",
      "onBeforeStartProdServer",
      "onAfterBuild",
      "onAfterCreateCompiler",
      "onAfterStartDevServer",
      "onAfterStartProdServer",
      "onCloseDevServer",
      "onDevCompileDone",
      "onExit",
      "getRsbuildConfig",
      "getNormalizedConfig"
    ]),
    ...pick(providerInstance, [
      "initConfigs",
      "inspectConfig",
      "createCompiler"
    ])
  };
  const getFlattenedPlugins = async (pluginOptions) => {
    let plugins = pluginOptions;
    do {
      plugins = (await Promise.all(plugins)).flat(
        Number.POSITIVE_INFINITY
      );
    } while (plugins.some((v) => (0, import_types3.isPromise)(v)));
    return plugins;
  };
  if (rsbuildConfig.plugins) {
    const plugins = await getFlattenedPlugins(rsbuildConfig.plugins);
    rsbuild.addPlugins(plugins);
  }
  if (rsbuildConfig.environments) {
    await Promise.all(
      Object.entries(rsbuildConfig.environments).map(async ([name, config]) => {
        const isEnvironmentEnabled = !rsbuildOptions.environment || rsbuildOptions.environment.includes(name);
        if (config.plugins && isEnvironmentEnabled) {
          const plugins = await getFlattenedPlugins(config.plugins);
          rsbuild.addPlugins(plugins, {
            environment: name
          });
        }
      })
    );
  }
  return rsbuild;
}
var import_types3, getRspackProvider;
var init_createRsbuild = __esm({
  "src/createRsbuild.ts"() {
    "use strict";
    import_types3 = require("util/types");
    init_createContext();
    init_helpers();
    init_initPlugins();
    init_internal();
    init_logger();
    init_pluginHelper();
    init_pluginManager();
    getRspackProvider = async () => {
      const { rspackProvider: rspackProvider2 } = await Promise.resolve().then(() => (init_provider(), provider_exports));
      return rspackProvider2;
    };
  }
});

// src/cli/init.ts
async function init({
  cliOptions,
  isRestart
}) {
  if (cliOptions) {
    commonOpts = cliOptions;
  }
  try {
    const cwd = process.cwd();
    const root = commonOpts.root ? getAbsolutePath(cwd, commonOpts.root) : cwd;
    const envs = loadEnv({
      cwd: getEnvDir(root, commonOpts.envDir),
      mode: commonOpts.envMode
    });
    onBeforeRestartServer(envs.cleanup);
    const { content: config, filePath: configFilePath } = await loadConfig({
      cwd: root,
      path: commonOpts.config,
      envMode: commonOpts.envMode
    });
    const command = process.argv[2];
    if (command === "dev") {
      const files = [...envs.filePaths];
      if (configFilePath) {
        files.push(configFilePath);
      }
      const { watchFiles: watchFilesConfig } = config.dev || {};
      if (watchFilesConfig?.type === "reload-server") {
        files.push(...castArray(watchFilesConfig.paths));
        watchFiles(files, watchFilesConfig.options);
      } else {
        watchFiles(files);
      }
    }
    const { createRsbuild: createRsbuild2 } = await Promise.resolve().then(() => (init_createRsbuild(), createRsbuild_exports));
    config.source ||= {};
    config.source.define = {
      ...envs.publicVars,
      ...config.source.define
    };
    if (commonOpts.root) {
      config.root = root;
    }
    if (commonOpts.mode) {
      config.mode = commonOpts.mode;
    }
    if (commonOpts.open && !config.server?.open) {
      config.server ||= {};
      config.server.open = commonOpts.open;
    }
    if (commonOpts.host) {
      config.server ||= {};
      config.server.host = commonOpts.host;
    }
    if (commonOpts.port) {
      config.server ||= {};
      config.server.port = commonOpts.port;
    }
    return createRsbuild2({
      cwd: root,
      rsbuildConfig: config,
      environment: commonOpts.environment
    });
  } catch (err) {
    if (isRestart) {
      import_rslog.logger.error(err);
    } else {
      throw err;
    }
  }
}
var import_node_path35, commonOpts, getEnvDir;
var init_init = __esm({
  "src/cli/init.ts"() {
    "use strict";
    import_node_path35 = __toESM(require("path"));
    init_config();
    init_helpers();
    init_loadEnv();
    init_logger();
    init_restart();
    commonOpts = {};
    getEnvDir = (cwd, envDir) => {
      if (envDir) {
        return import_node_path35.default.isAbsolute(envDir) ? envDir : import_node_path35.default.resolve(cwd, envDir);
      }
      return cwd;
    };
  }
});

// src/cli/commands.ts
function runCli() {
  import_commander.program.name("rsbuild").usage("<command> [options]").version("1.0.4");
  const devCommand = import_commander.program.command("dev");
  const buildCommand = import_commander.program.command("build");
  const previewCommand = import_commander.program.command("preview");
  const inspectCommand = import_commander.program.command("inspect");
  [devCommand, buildCommand, previewCommand, inspectCommand].forEach(
    applyCommonOptions
  );
  [devCommand, previewCommand].forEach(applyServerOptions);
  devCommand.description("starting the dev server").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.startDevServer();
    } catch (err) {
      import_rslog.logger.error("Failed to start dev server.");
      import_rslog.logger.error(err);
      process.exit(1);
    }
  });
  buildCommand.option("-w --watch", "turn on watch mode, watch for changes and rebuild").description("build the app for production").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.build({
        watch: options.watch
      });
    } catch (err) {
      import_rslog.logger.error("Failed to build.");
      import_rslog.logger.error(err);
      process.exit(1);
    }
  });
  previewCommand.description("preview the production build locally").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.initConfigs();
      if (rsbuild) {
        const { distPath } = rsbuild.context;
        if (!(0, import_node_fs11.existsSync)(distPath)) {
          throw new Error(
            `The output directory ${import_picocolors16.default.yellow(
              distPath
            )} does not exist, please build the project before previewing.`
          );
        }
        if (isEmptyDir(distPath)) {
          throw new Error(
            `The output directory ${import_picocolors16.default.yellow(
              distPath
            )} is empty, please build the project before previewing.`
          );
        }
      }
      await rsbuild?.preview();
    } catch (err) {
      import_rslog.logger.error("Failed to start preview server.");
      import_rslog.logger.error(err);
      process.exit(1);
    }
  });
  inspectCommand.description("inspect the Rspack and Rsbuild configs").option("--output <output>", "specify inspect content output path").option("--verbose", "show full function definitions in output").action(async (options) => {
    try {
      const rsbuild = await init({ cliOptions: options });
      await rsbuild?.inspectConfig({
        verbose: options.verbose,
        outputPath: options.output,
        writeToDisk: true
      });
    } catch (err) {
      import_rslog.logger.error("Failed to inspect config.");
      import_rslog.logger.error(err);
      process.exit(1);
    }
  });
  import_commander.program.parse();
}
var import_node_fs11, import_commander, import_picocolors16, applyCommonOptions, applyServerOptions;
var init_commands = __esm({
  "src/cli/commands.ts"() {
    "use strict";
    import_node_fs11 = require("fs");
    import_commander = require("../compiled/commander/index.js");
    import_picocolors16 = __toESM(require("../compiled/picocolors/index.js"));
    init_helpers();
    init_logger();
    init_init();
    applyCommonOptions = (command) => {
      command.option(
        "-c --config <config>",
        "specify the configuration file, can be a relative or absolute path"
      ).option(
        "-r --root <root>",
        "specify the project root directory, can be an absolute path or a path relative to cwd"
      ).option(
        "-m --mode <mode>",
        "specify the build mode, can be `development`, `production` or `none`"
      ).option(
        "--env-mode <mode>",
        "specify the env mode to load the `.env.[mode]` file"
      ).option(
        "--environment <name>",
        "specify the name of environment to build",
        (str, prev) => prev ? prev.concat(str.split(",")) : str.split(",")
      ).option("--env-dir <dir>", "specify the directory to load `.env` files");
    };
    applyServerOptions = (command) => {
      command.option("-o --open [url]", "open the page in browser on startup").option("--port <port>", "specify a port number for server to listen").option("--host <host>", "specify the host that the server listens to");
    };
  }
});

// src/cli/prepare.ts
function initNodeEnv() {
  if (!process.env.NODE_ENV) {
    const command = process.argv[2];
    process.env.NODE_ENV = ["build", "preview"].includes(command) ? "production" : "development";
  }
}
function prepareCli() {
  initNodeEnv();
  const { npm_execpath } = process.env;
  if (!npm_execpath || npm_execpath.includes("npx-cli.js") || npm_execpath.includes(".bun")) {
    console.log();
  }
  import_rslog.logger.greet(`  ${`Rsbuild v${"1.0.4"}`}
`);
}
var init_prepare = __esm({
  "src/cli/prepare.ts"() {
    "use strict";
    init_logger();
  }
});

// src/internal.ts
var internal_exports = {};
__export(internal_exports, {
  applySwcDecoratorConfig: () => applySwcDecoratorConfig,
  chainToConfig: () => chainToConfig,
  createDevServer: () => createDevServer,
  createPluginManager: () => createPluginManager,
  formatStats: () => formatStats,
  getChainUtils: () => getChainUtils,
  getConfigUtils: () => getConfigUtils,
  getHTMLPlugin: () => getHTMLPlugin,
  getRsbuildInspectConfig: () => getRsbuildInspectConfig,
  getStatsOptions: () => getStatsOptions,
  getSwcMinimizerOptions: () => getSwcMinimizerOptions,
  initHooks: () => initHooks,
  initPlugins: () => initPlugins,
  initRsbuildConfig: () => initRsbuildConfig,
  modifyBundlerChain: () => modifyBundlerChain,
  onCompileDone: () => onCompileDone,
  outputInspectConfigFiles: () => outputInspectConfigFiles,
  prepareCli: () => prepareCli,
  prettyTime: () => prettyTime,
  registerBuildHook: () => registerBuildHook,
  registerDevHook: () => registerDevHook,
  runCli: () => runCli,
  setHTMLPlugin: () => setHTMLPlugin,
  stringifyConfig: () => stringifyConfig
});
var init_internal = __esm({
  "src/internal.ts"() {
    "use strict";
    init_commands();
    init_prepare();
    init_pluginManager();
    init_hooks();
    init_initConfigs();
    init_config();
    init_pluginHelper();
    init_helpers();
    init_hooks();
    init_rspackConfig();
    init_configChain();
    init_swc();
    init_minimize();
    init_devServer();
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PLUGIN_CSS_NAME: () => PLUGIN_CSS_NAME,
  PLUGIN_SWC_NAME: () => PLUGIN_SWC_NAME,
  __internalHelper: () => internal_exports,
  createRsbuild: () => createRsbuild,
  defineConfig: () => defineConfig,
  ensureAssetPrefix: () => ensureAssetPrefix,
  loadConfig: () => loadConfig,
  loadEnv: () => loadEnv,
  logger: () => import_rslog.logger,
  mergeRsbuildConfig: () => mergeRsbuildConfig,
  rspack: () => import_core10.rspack,
  version: () => version
});
module.exports = __toCommonJS(src_exports);
var import_core10 = require("@rspack/core");
init_internal();
init_loadEnv();
init_createRsbuild();
init_config();
init_logger();
init_mergeConfig();
init_helpers();
init_constants();
var version = "1.0.4";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PLUGIN_CSS_NAME,
  PLUGIN_SWC_NAME,
  __internalHelper,
  createRsbuild,
  defineConfig,
  ensureAssetPrefix,
  loadConfig,
  loadEnv,
  logger,
  mergeRsbuildConfig,
  rspack,
  version
});
